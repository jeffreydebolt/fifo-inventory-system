{"ast":null,"code":"import { defineIntegration, convertIntegrationFnToClass, getClient, captureEvent, isSentryRequestUrl } from '@sentry/core';\nimport { supportsNativeFetch, addFetchInstrumentationHandler, GLOBAL_OBJ, addXhrInstrumentationHandler, SENTRY_XHR_DATA_KEY, logger, addExceptionMechanism } from '@sentry/utils';\nimport { DEBUG_BUILD } from './debug-build.js';\nconst INTEGRATION_NAME = 'HttpClient';\nconst _httpClientIntegration = function () {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const _options = {\n    failedRequestStatusCodes: [[500, 599]],\n    failedRequestTargets: [/.*/],\n    ...options\n  };\n  return {\n    name: INTEGRATION_NAME,\n    // TODO v8: Remove this\n    setupOnce() {},\n    // eslint-disable-line @typescript-eslint/no-empty-function\n    setup(client) {\n      _wrapFetch(client, _options);\n      _wrapXHR(client, _options);\n    }\n  };\n};\nconst httpClientIntegration = defineIntegration(_httpClientIntegration);\n\n/**\n * Create events for failed client side HTTP requests.\n * @deprecated Use `httpClientIntegration()` instead.\n */\n// eslint-disable-next-line deprecation/deprecation\nconst HttpClient = convertIntegrationFnToClass(INTEGRATION_NAME, httpClientIntegration);\n\n/**\n * Interceptor function for fetch requests\n *\n * @param requestInfo The Fetch API request info\n * @param response The Fetch API response\n * @param requestInit The request init object\n */\nfunction _fetchResponseHandler(options, requestInfo, response, requestInit) {\n  if (_shouldCaptureResponse(options, response.status, response.url)) {\n    const request = _getRequest(requestInfo, requestInit);\n    let requestHeaders, responseHeaders, requestCookies, responseCookies;\n    if (_shouldSendDefaultPii()) {\n      [{\n        headers: requestHeaders,\n        cookies: requestCookies\n      }, {\n        headers: responseHeaders,\n        cookies: responseCookies\n      }] = [{\n        cookieHeader: 'Cookie',\n        obj: request\n      }, {\n        cookieHeader: 'Set-Cookie',\n        obj: response\n      }].map(_ref => {\n        let {\n          cookieHeader,\n          obj\n        } = _ref;\n        const headers = _extractFetchHeaders(obj.headers);\n        let cookies;\n        try {\n          const cookieString = headers[cookieHeader] || headers[cookieHeader.toLowerCase()] || undefined;\n          if (cookieString) {\n            cookies = _parseCookieString(cookieString);\n          }\n        } catch (e) {\n          DEBUG_BUILD && logger.log(`Could not extract cookies from header ${cookieHeader}`);\n        }\n        return {\n          headers,\n          cookies\n        };\n      });\n    }\n    const event = _createEvent({\n      url: request.url,\n      method: request.method,\n      status: response.status,\n      requestHeaders,\n      responseHeaders,\n      requestCookies,\n      responseCookies\n    });\n    captureEvent(event);\n  }\n}\n\n/**\n * Interceptor function for XHR requests\n *\n * @param xhr The XHR request\n * @param method The HTTP method\n * @param headers The HTTP headers\n */\nfunction _xhrResponseHandler(options, xhr, method, headers) {\n  if (_shouldCaptureResponse(options, xhr.status, xhr.responseURL)) {\n    let requestHeaders, responseCookies, responseHeaders;\n    if (_shouldSendDefaultPii()) {\n      try {\n        const cookieString = xhr.getResponseHeader('Set-Cookie') || xhr.getResponseHeader('set-cookie') || undefined;\n        if (cookieString) {\n          responseCookies = _parseCookieString(cookieString);\n        }\n      } catch (e) {\n        DEBUG_BUILD && logger.log('Could not extract cookies from response headers');\n      }\n      try {\n        responseHeaders = _getXHRResponseHeaders(xhr);\n      } catch (e) {\n        DEBUG_BUILD && logger.log('Could not extract headers from response');\n      }\n      requestHeaders = headers;\n    }\n    const event = _createEvent({\n      url: xhr.responseURL,\n      method,\n      status: xhr.status,\n      requestHeaders,\n      // Can't access request cookies from XHR\n      responseHeaders,\n      responseCookies\n    });\n    captureEvent(event);\n  }\n}\n\n/**\n * Extracts response size from `Content-Length` header when possible\n *\n * @param headers\n * @returns The response size in bytes or undefined\n */\nfunction _getResponseSizeFromHeaders(headers) {\n  if (headers) {\n    const contentLength = headers['Content-Length'] || headers['content-length'];\n    if (contentLength) {\n      return parseInt(contentLength, 10);\n    }\n  }\n  return undefined;\n}\n\n/**\n * Creates an object containing cookies from the given cookie string\n *\n * @param cookieString The cookie string to parse\n * @returns The parsed cookies\n */\nfunction _parseCookieString(cookieString) {\n  return cookieString.split('; ').reduce((acc, cookie) => {\n    const [key, value] = cookie.split('=');\n    acc[key] = value;\n    return acc;\n  }, {});\n}\n\n/**\n * Extracts the headers as an object from the given Fetch API request or response object\n *\n * @param headers The headers to extract\n * @returns The extracted headers as an object\n */\nfunction _extractFetchHeaders(headers) {\n  const result = {};\n  headers.forEach((value, key) => {\n    result[key] = value;\n  });\n  return result;\n}\n\n/**\n * Extracts the response headers as an object from the given XHR object\n *\n * @param xhr The XHR object to extract the response headers from\n * @returns The response headers as an object\n */\nfunction _getXHRResponseHeaders(xhr) {\n  const headers = xhr.getAllResponseHeaders();\n  if (!headers) {\n    return {};\n  }\n  return headers.split('\\r\\n').reduce((acc, line) => {\n    const [key, value] = line.split(': ');\n    acc[key] = value;\n    return acc;\n  }, {});\n}\n\n/**\n * Checks if the given target url is in the given list of targets\n *\n * @param target The target url to check\n * @returns true if the target url is in the given list of targets, false otherwise\n */\nfunction _isInGivenRequestTargets(failedRequestTargets, target) {\n  return failedRequestTargets.some(givenRequestTarget => {\n    if (typeof givenRequestTarget === 'string') {\n      return target.includes(givenRequestTarget);\n    }\n    return givenRequestTarget.test(target);\n  });\n}\n\n/**\n * Checks if the given status code is in the given range\n *\n * @param status The status code to check\n * @returns true if the status code is in the given range, false otherwise\n */\nfunction _isInGivenStatusRanges(failedRequestStatusCodes, status) {\n  return failedRequestStatusCodes.some(range => {\n    if (typeof range === 'number') {\n      return range === status;\n    }\n    return status >= range[0] && status <= range[1];\n  });\n}\n\n/**\n * Wraps `fetch` function to capture request and response data\n */\nfunction _wrapFetch(client, options) {\n  if (!supportsNativeFetch()) {\n    return;\n  }\n  addFetchInstrumentationHandler(handlerData => {\n    if (getClient() !== client) {\n      return;\n    }\n    const {\n      response,\n      args\n    } = handlerData;\n    const [requestInfo, requestInit] = args;\n    if (!response) {\n      return;\n    }\n    _fetchResponseHandler(options, requestInfo, response, requestInit);\n  });\n}\n\n/**\n * Wraps XMLHttpRequest to capture request and response data\n */\nfunction _wrapXHR(client, options) {\n  if (!('XMLHttpRequest' in GLOBAL_OBJ)) {\n    return;\n  }\n  addXhrInstrumentationHandler(handlerData => {\n    if (getClient() !== client) {\n      return;\n    }\n    const xhr = handlerData.xhr;\n    const sentryXhrData = xhr[SENTRY_XHR_DATA_KEY];\n    if (!sentryXhrData) {\n      return;\n    }\n    const {\n      method,\n      request_headers: headers\n    } = sentryXhrData;\n    try {\n      _xhrResponseHandler(options, xhr, method, headers);\n    } catch (e) {\n      DEBUG_BUILD && logger.warn('Error while extracting response event form XHR response', e);\n    }\n  });\n}\n\n/**\n * Checks whether to capture given response as an event\n *\n * @param status response status code\n * @param url response url\n */\nfunction _shouldCaptureResponse(options, status, url) {\n  return _isInGivenStatusRanges(options.failedRequestStatusCodes, status) && _isInGivenRequestTargets(options.failedRequestTargets, url) && !isSentryRequestUrl(url, getClient());\n}\n\n/**\n * Creates a synthetic Sentry event from given response data\n *\n * @param data response data\n * @returns event\n */\nfunction _createEvent(data) {\n  const message = `HTTP Client Error with status code: ${data.status}`;\n  const event = {\n    message,\n    exception: {\n      values: [{\n        type: 'Error',\n        value: message\n      }]\n    },\n    request: {\n      url: data.url,\n      method: data.method,\n      headers: data.requestHeaders,\n      cookies: data.requestCookies\n    },\n    contexts: {\n      response: {\n        status_code: data.status,\n        headers: data.responseHeaders,\n        cookies: data.responseCookies,\n        body_size: _getResponseSizeFromHeaders(data.responseHeaders)\n      }\n    }\n  };\n  addExceptionMechanism(event, {\n    type: 'http.client',\n    handled: false\n  });\n  return event;\n}\nfunction _getRequest(requestInfo, requestInit) {\n  if (!requestInit && requestInfo instanceof Request) {\n    return requestInfo;\n  }\n\n  // If both are set, we try to construct a new Request with the given arguments\n  // However, if e.g. the original request has a `body`, this will throw an error because it was already accessed\n  // In this case, as a fallback, we just use the original request - using both is rather an edge case\n  if (requestInfo instanceof Request && requestInfo.bodyUsed) {\n    return requestInfo;\n  }\n  return new Request(requestInfo, requestInit);\n}\nfunction _shouldSendDefaultPii() {\n  const client = getClient();\n  return client ? Boolean(client.getOptions().sendDefaultPii) : false;\n}\nexport { HttpClient, httpClientIntegration };","map":{"version":3,"names":["INTEGRATION_NAME","_httpClientIntegration","options","arguments","length","undefined","_options","failedRequestStatusCodes","failedRequestTargets","name","setupOnce","setup","client","_wrapFetch","_wrapXHR","httpClientIntegration","defineIntegration","HttpClient","convertIntegrationFnToClass","_fetchResponseHandler","requestInfo","response","requestInit","_shouldCaptureResponse","status","url","request","_getRequest","requestHeaders","responseHeaders","requestCookies","responseCookies","_shouldSendDefaultPii","headers","cookies","cookieHeader","obj","map","_ref","_extractFetchHeaders","cookieString","toLowerCase","_parseCookieString","e","DEBUG_BUILD","logger","log","event","_createEvent","method","captureEvent","_xhrResponseHandler","xhr","responseURL","getResponseHeader","_getXHRResponseHeaders","_getResponseSizeFromHeaders","contentLength","parseInt","split","reduce","acc","cookie","key","value","result","forEach","getAllResponseHeaders","line","_isInGivenRequestTargets","target","some","givenRequestTarget","includes","test","_isInGivenStatusRanges","range","supportsNativeFetch","addFetchInstrumentationHandler","handlerData","getClient","args","GLOBAL_OBJ","addXhrInstrumentationHandler","sentryXhrData","SENTRY_XHR_DATA_KEY","request_headers","warn","isSentryRequestUrl","data","message","exception","values","type","contexts","status_code","body_size","addExceptionMechanism","handled","Request","bodyUsed","Boolean","getOptions","sendDefaultPii"],"sources":["/Users/jeffreydebolt/Documents/fifo/cogs-dashboard/node_modules/src/httpclient.ts"],"sourcesContent":["import {\n  captureEvent,\n  convertIntegrationFnToClass,\n  defineIntegration,\n  getClient,\n  isSentryRequestUrl,\n} from '@sentry/core';\nimport type {\n  Client,\n  Event as SentryEvent,\n  Integration,\n  IntegrationClass,\n  IntegrationFn,\n  SentryWrappedXMLHttpRequest,\n} from '@sentry/types';\nimport {\n  GLOBAL_OBJ,\n  SENTRY_XHR_DATA_KEY,\n  addExceptionMechanism,\n  addFetchInstrumentationHandler,\n  addXhrInstrumentationHandler,\n  logger,\n  supportsNativeFetch,\n} from '@sentry/utils';\n\nimport { DEBUG_BUILD } from './debug-build';\n\nexport type HttpStatusCodeRange = [number, number] | number;\nexport type HttpRequestTarget = string | RegExp;\n\nconst INTEGRATION_NAME = 'HttpClient';\n\ninterface HttpClientOptions {\n  /**\n   * HTTP status codes that should be considered failed.\n   * This array can contain tuples of `[begin, end]` (both inclusive),\n   * single status codes, or a combinations of both\n   *\n   * Example: [[500, 505], 507]\n   * Default: [[500, 599]]\n   */\n  failedRequestStatusCodes: HttpStatusCodeRange[];\n\n  /**\n   * Targets to track for failed requests.\n   * This array can contain strings or regular expressions.\n   *\n   * Example: ['http://localhost', /api\\/.*\\/]\n   * Default: [/.*\\/]\n   */\n  failedRequestTargets: HttpRequestTarget[];\n}\n\nconst _httpClientIntegration = ((options: Partial<HttpClientOptions> = {}) => {\n  const _options: HttpClientOptions = {\n    failedRequestStatusCodes: [[500, 599]],\n    failedRequestTargets: [/.*/],\n    ...options,\n  };\n\n  return {\n    name: INTEGRATION_NAME,\n    // TODO v8: Remove this\n    setupOnce() {}, // eslint-disable-line @typescript-eslint/no-empty-function\n    setup(client): void {\n      _wrapFetch(client, _options);\n      _wrapXHR(client, _options);\n    },\n  };\n}) satisfies IntegrationFn;\n\nexport const httpClientIntegration = defineIntegration(_httpClientIntegration);\n\n/**\n * Create events for failed client side HTTP requests.\n * @deprecated Use `httpClientIntegration()` instead.\n */\n// eslint-disable-next-line deprecation/deprecation\nexport const HttpClient = convertIntegrationFnToClass(INTEGRATION_NAME, httpClientIntegration) as IntegrationClass<\n  Integration & { setup: (client: Client) => void }\n> & {\n  new (options?: {\n    failedRequestStatusCodes: HttpStatusCodeRange[];\n    failedRequestTargets: HttpRequestTarget[];\n  }): Integration;\n};\n\n/**\n * Interceptor function for fetch requests\n *\n * @param requestInfo The Fetch API request info\n * @param response The Fetch API response\n * @param requestInit The request init object\n */\nfunction _fetchResponseHandler(\n  options: HttpClientOptions,\n  requestInfo: RequestInfo,\n  response: Response,\n  requestInit?: RequestInit,\n): void {\n  if (_shouldCaptureResponse(options, response.status, response.url)) {\n    const request = _getRequest(requestInfo, requestInit);\n\n    let requestHeaders, responseHeaders, requestCookies, responseCookies;\n\n    if (_shouldSendDefaultPii()) {\n      [{ headers: requestHeaders, cookies: requestCookies }, { headers: responseHeaders, cookies: responseCookies }] = [\n        { cookieHeader: 'Cookie', obj: request },\n        { cookieHeader: 'Set-Cookie', obj: response },\n      ].map(({ cookieHeader, obj }) => {\n        const headers = _extractFetchHeaders(obj.headers);\n        let cookies;\n\n        try {\n          const cookieString = headers[cookieHeader] || headers[cookieHeader.toLowerCase()] || undefined;\n\n          if (cookieString) {\n            cookies = _parseCookieString(cookieString);\n          }\n        } catch (e) {\n          DEBUG_BUILD && logger.log(`Could not extract cookies from header ${cookieHeader}`);\n        }\n\n        return {\n          headers,\n          cookies,\n        };\n      });\n    }\n\n    const event = _createEvent({\n      url: request.url,\n      method: request.method,\n      status: response.status,\n      requestHeaders,\n      responseHeaders,\n      requestCookies,\n      responseCookies,\n    });\n\n    captureEvent(event);\n  }\n}\n\n/**\n * Interceptor function for XHR requests\n *\n * @param xhr The XHR request\n * @param method The HTTP method\n * @param headers The HTTP headers\n */\nfunction _xhrResponseHandler(\n  options: HttpClientOptions,\n  xhr: XMLHttpRequest,\n  method: string,\n  headers: Record<string, string>,\n): void {\n  if (_shouldCaptureResponse(options, xhr.status, xhr.responseURL)) {\n    let requestHeaders, responseCookies, responseHeaders;\n\n    if (_shouldSendDefaultPii()) {\n      try {\n        const cookieString = xhr.getResponseHeader('Set-Cookie') || xhr.getResponseHeader('set-cookie') || undefined;\n\n        if (cookieString) {\n          responseCookies = _parseCookieString(cookieString);\n        }\n      } catch (e) {\n        DEBUG_BUILD && logger.log('Could not extract cookies from response headers');\n      }\n\n      try {\n        responseHeaders = _getXHRResponseHeaders(xhr);\n      } catch (e) {\n        DEBUG_BUILD && logger.log('Could not extract headers from response');\n      }\n\n      requestHeaders = headers;\n    }\n\n    const event = _createEvent({\n      url: xhr.responseURL,\n      method,\n      status: xhr.status,\n      requestHeaders,\n      // Can't access request cookies from XHR\n      responseHeaders,\n      responseCookies,\n    });\n\n    captureEvent(event);\n  }\n}\n\n/**\n * Extracts response size from `Content-Length` header when possible\n *\n * @param headers\n * @returns The response size in bytes or undefined\n */\nfunction _getResponseSizeFromHeaders(headers?: Record<string, string>): number | undefined {\n  if (headers) {\n    const contentLength = headers['Content-Length'] || headers['content-length'];\n\n    if (contentLength) {\n      return parseInt(contentLength, 10);\n    }\n  }\n\n  return undefined;\n}\n\n/**\n * Creates an object containing cookies from the given cookie string\n *\n * @param cookieString The cookie string to parse\n * @returns The parsed cookies\n */\nfunction _parseCookieString(cookieString: string): Record<string, string> {\n  return cookieString.split('; ').reduce((acc: Record<string, string>, cookie: string) => {\n    const [key, value] = cookie.split('=');\n    acc[key] = value;\n    return acc;\n  }, {});\n}\n\n/**\n * Extracts the headers as an object from the given Fetch API request or response object\n *\n * @param headers The headers to extract\n * @returns The extracted headers as an object\n */\nfunction _extractFetchHeaders(headers: Headers): Record<string, string> {\n  const result: Record<string, string> = {};\n\n  headers.forEach((value, key) => {\n    result[key] = value;\n  });\n\n  return result;\n}\n\n/**\n * Extracts the response headers as an object from the given XHR object\n *\n * @param xhr The XHR object to extract the response headers from\n * @returns The response headers as an object\n */\nfunction _getXHRResponseHeaders(xhr: XMLHttpRequest): Record<string, string> {\n  const headers = xhr.getAllResponseHeaders();\n\n  if (!headers) {\n    return {};\n  }\n\n  return headers.split('\\r\\n').reduce((acc: Record<string, string>, line: string) => {\n    const [key, value] = line.split(': ');\n    acc[key] = value;\n    return acc;\n  }, {});\n}\n\n/**\n * Checks if the given target url is in the given list of targets\n *\n * @param target The target url to check\n * @returns true if the target url is in the given list of targets, false otherwise\n */\nfunction _isInGivenRequestTargets(\n  failedRequestTargets: HttpClientOptions['failedRequestTargets'],\n  target: string,\n): boolean {\n  return failedRequestTargets.some((givenRequestTarget: HttpRequestTarget) => {\n    if (typeof givenRequestTarget === 'string') {\n      return target.includes(givenRequestTarget);\n    }\n\n    return givenRequestTarget.test(target);\n  });\n}\n\n/**\n * Checks if the given status code is in the given range\n *\n * @param status The status code to check\n * @returns true if the status code is in the given range, false otherwise\n */\nfunction _isInGivenStatusRanges(\n  failedRequestStatusCodes: HttpClientOptions['failedRequestStatusCodes'],\n  status: number,\n): boolean {\n  return failedRequestStatusCodes.some((range: HttpStatusCodeRange) => {\n    if (typeof range === 'number') {\n      return range === status;\n    }\n\n    return status >= range[0] && status <= range[1];\n  });\n}\n\n/**\n * Wraps `fetch` function to capture request and response data\n */\nfunction _wrapFetch(client: Client, options: HttpClientOptions): void {\n  if (!supportsNativeFetch()) {\n    return;\n  }\n\n  addFetchInstrumentationHandler(handlerData => {\n    if (getClient() !== client) {\n      return;\n    }\n\n    const { response, args } = handlerData;\n    const [requestInfo, requestInit] = args as [RequestInfo, RequestInit | undefined];\n\n    if (!response) {\n      return;\n    }\n\n    _fetchResponseHandler(options, requestInfo, response as Response, requestInit);\n  });\n}\n\n/**\n * Wraps XMLHttpRequest to capture request and response data\n */\nfunction _wrapXHR(client: Client, options: HttpClientOptions): void {\n  if (!('XMLHttpRequest' in GLOBAL_OBJ)) {\n    return;\n  }\n\n  addXhrInstrumentationHandler(handlerData => {\n    if (getClient() !== client) {\n      return;\n    }\n\n    const xhr = handlerData.xhr as SentryWrappedXMLHttpRequest & XMLHttpRequest;\n\n    const sentryXhrData = xhr[SENTRY_XHR_DATA_KEY];\n\n    if (!sentryXhrData) {\n      return;\n    }\n\n    const { method, request_headers: headers } = sentryXhrData;\n\n    try {\n      _xhrResponseHandler(options, xhr, method, headers);\n    } catch (e) {\n      DEBUG_BUILD && logger.warn('Error while extracting response event form XHR response', e);\n    }\n  });\n}\n\n/**\n * Checks whether to capture given response as an event\n *\n * @param status response status code\n * @param url response url\n */\nfunction _shouldCaptureResponse(options: HttpClientOptions, status: number, url: string): boolean {\n  return (\n    _isInGivenStatusRanges(options.failedRequestStatusCodes, status) &&\n    _isInGivenRequestTargets(options.failedRequestTargets, url) &&\n    !isSentryRequestUrl(url, getClient())\n  );\n}\n\n/**\n * Creates a synthetic Sentry event from given response data\n *\n * @param data response data\n * @returns event\n */\nfunction _createEvent(data: {\n  url: string;\n  method: string;\n  status: number;\n  responseHeaders?: Record<string, string>;\n  responseCookies?: Record<string, string>;\n  requestHeaders?: Record<string, string>;\n  requestCookies?: Record<string, string>;\n}): SentryEvent {\n  const message = `HTTP Client Error with status code: ${data.status}`;\n\n  const event: SentryEvent = {\n    message,\n    exception: {\n      values: [\n        {\n          type: 'Error',\n          value: message,\n        },\n      ],\n    },\n    request: {\n      url: data.url,\n      method: data.method,\n      headers: data.requestHeaders,\n      cookies: data.requestCookies,\n    },\n    contexts: {\n      response: {\n        status_code: data.status,\n        headers: data.responseHeaders,\n        cookies: data.responseCookies,\n        body_size: _getResponseSizeFromHeaders(data.responseHeaders),\n      },\n    },\n  };\n\n  addExceptionMechanism(event, {\n    type: 'http.client',\n    handled: false,\n  });\n\n  return event;\n}\n\nfunction _getRequest(requestInfo: RequestInfo, requestInit?: RequestInit): Request {\n  if (!requestInit && requestInfo instanceof Request) {\n    return requestInfo;\n  }\n\n  // If both are set, we try to construct a new Request with the given arguments\n  // However, if e.g. the original request has a `body`, this will throw an error because it was already accessed\n  // In this case, as a fallback, we just use the original request - using both is rather an edge case\n  if (requestInfo instanceof Request && requestInfo.bodyUsed) {\n    return requestInfo;\n  }\n\n  return new Request(requestInfo, requestInit);\n}\n\nfunction _shouldSendDefaultPii(): boolean {\n  const client = getClient();\n  return client ? Boolean(client.getOptions().sendDefaultPii) : false;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}