{"ast":null,"code":"import { isString } from '../is.js';\nimport { fill } from '../object.js';\nimport { GLOBAL_OBJ } from '../worldwide.js';\nimport { addHandler, maybeInstrument, triggerHandlers } from './_handlers.js';\nconst WINDOW = GLOBAL_OBJ;\nconst SENTRY_XHR_DATA_KEY = '__sentry_xhr_v3__';\n\n/**\n * Add an instrumentation handler for when an XHR request happens.\n * The handler function is called once when the request starts and once when it ends,\n * which can be identified by checking if it has an `endTimestamp`.\n *\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nfunction addXhrInstrumentationHandler(handler) {\n  const type = 'xhr';\n  addHandler(type, handler);\n  maybeInstrument(type, instrumentXHR);\n}\n\n/** Exported only for tests. */\nfunction instrumentXHR() {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  if (!WINDOW.XMLHttpRequest) {\n    return;\n  }\n  const xhrproto = XMLHttpRequest.prototype;\n  fill(xhrproto, 'open', function (originalOpen) {\n    return function () {\n      const startTimestamp = Date.now();\n\n      // open() should always be called with two or more arguments\n      // But to be on the safe side, we actually validate this and bail out if we don't have a method & url\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      const method = isString(args[0]) ? args[0].toUpperCase() : undefined;\n      const url = parseUrl(args[1]);\n      if (!method || !url) {\n        return originalOpen.apply(this, args);\n      }\n      this[SENTRY_XHR_DATA_KEY] = {\n        method,\n        url,\n        request_headers: {}\n      };\n\n      // if Sentry key appears in URL, don't capture it as a request\n      if (method === 'POST' && url.match(/sentry_key/)) {\n        this.__sentry_own_request__ = true;\n      }\n      const onreadystatechangeHandler = () => {\n        // For whatever reason, this is not the same instance here as from the outer method\n        const xhrInfo = this[SENTRY_XHR_DATA_KEY];\n        if (!xhrInfo) {\n          return;\n        }\n        if (this.readyState === 4) {\n          try {\n            // touching statusCode in some platforms throws\n            // an exception\n            xhrInfo.status_code = this.status;\n          } catch (e) {\n            /* do nothing */\n          }\n          const handlerData = {\n            args: [method, url],\n            endTimestamp: Date.now(),\n            startTimestamp,\n            xhr: this\n          };\n          triggerHandlers('xhr', handlerData);\n        }\n      };\n      if ('onreadystatechange' in this && typeof this.onreadystatechange === 'function') {\n        fill(this, 'onreadystatechange', function (original) {\n          return function () {\n            onreadystatechangeHandler();\n            for (var _len2 = arguments.length, readyStateArgs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n              readyStateArgs[_key2] = arguments[_key2];\n            }\n            return original.apply(this, readyStateArgs);\n          };\n        });\n      } else {\n        this.addEventListener('readystatechange', onreadystatechangeHandler);\n      }\n\n      // Intercepting `setRequestHeader` to access the request headers of XHR instance.\n      // This will only work for user/library defined headers, not for the default/browser-assigned headers.\n      // Request cookies are also unavailable for XHR, as `Cookie` header can't be defined by `setRequestHeader`.\n      fill(this, 'setRequestHeader', function (original) {\n        return function () {\n          for (var _len3 = arguments.length, setRequestHeaderArgs = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n            setRequestHeaderArgs[_key3] = arguments[_key3];\n          }\n          const [header, value] = setRequestHeaderArgs;\n          const xhrInfo = this[SENTRY_XHR_DATA_KEY];\n          if (xhrInfo && isString(header) && isString(value)) {\n            xhrInfo.request_headers[header.toLowerCase()] = value;\n          }\n          return original.apply(this, setRequestHeaderArgs);\n        };\n      });\n      return originalOpen.apply(this, args);\n    };\n  });\n  fill(xhrproto, 'send', function (originalSend) {\n    return function () {\n      const sentryXhrData = this[SENTRY_XHR_DATA_KEY];\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      if (!sentryXhrData) {\n        return originalSend.apply(this, args);\n      }\n      if (args[0] !== undefined) {\n        sentryXhrData.body = args[0];\n      }\n      const handlerData = {\n        args: [sentryXhrData.method, sentryXhrData.url],\n        startTimestamp: Date.now(),\n        xhr: this\n      };\n      triggerHandlers('xhr', handlerData);\n      return originalSend.apply(this, args);\n    };\n  });\n}\nfunction parseUrl(url) {\n  if (isString(url)) {\n    return url;\n  }\n  try {\n    // url can be a string or URL\n    // but since URL is not available in IE11, we do not check for it,\n    // but simply assume it is an URL and return `toString()` from it (which returns the full URL)\n    // If that fails, we just return undefined\n    return url.toString();\n  } catch (e2) {} // eslint-disable-line no-empty\n\n  return undefined;\n}\nexport { SENTRY_XHR_DATA_KEY, addXhrInstrumentationHandler, instrumentXHR };","map":{"version":3,"names":["WINDOW","GLOBAL_OBJ","SENTRY_XHR_DATA_KEY","addXhrInstrumentationHandler","handler","type","addHandler","maybeInstrument","instrumentXHR","XMLHttpRequest","xhrproto","prototype","fill","originalOpen","startTimestamp","Date","now","_len","arguments","length","args","Array","_key","method","isString","toUpperCase","undefined","url","parseUrl","apply","request_headers","match","__sentry_own_request__","onreadystatechangeHandler","xhrInfo","readyState","status_code","status","e","handlerData","endTimestamp","xhr","triggerHandlers","onreadystatechange","original","_len2","readyStateArgs","_key2","addEventListener","_len3","setRequestHeaderArgs","_key3","header","value","toLowerCase","originalSend","sentryXhrData","_len4","_key4","body","toString","e2"],"sources":["/Users/jeffreydebolt/Documents/fifo/cogs-dashboard/node_modules/@sentry/src/instrument/xhr.ts"],"sourcesContent":["// TODO(v8): Move everything in this file into the browser package. Nothing here is generic and we run risk of leaking browser types into non-browser packages.\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/ban-types */\nimport type { HandlerDataXhr, SentryWrappedXMLHttpRequest, WrappedFunction } from '@sentry/types';\n\nimport { isString } from '../is';\nimport { fill } from '../object';\nimport { GLOBAL_OBJ } from '../worldwide';\nimport { addHandler, maybeInstrument, triggerHandlers } from './_handlers';\n\nconst WINDOW = GLOBAL_OBJ as unknown as Window;\n\nexport const SENTRY_XHR_DATA_KEY = '__sentry_xhr_v3__';\n\n/**\n * Add an instrumentation handler for when an XHR request happens.\n * The handler function is called once when the request starts and once when it ends,\n * which can be identified by checking if it has an `endTimestamp`.\n *\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nexport function addXhrInstrumentationHandler(handler: (data: HandlerDataXhr) => void): void {\n  const type = 'xhr';\n  addHandler(type, handler);\n  maybeInstrument(type, instrumentXHR);\n}\n\n/** Exported only for tests. */\nexport function instrumentXHR(): void {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  if (!(WINDOW as any).XMLHttpRequest) {\n    return;\n  }\n\n  const xhrproto = XMLHttpRequest.prototype;\n\n  fill(xhrproto, 'open', function (originalOpen: () => void): () => void {\n    return function (this: XMLHttpRequest & SentryWrappedXMLHttpRequest, ...args: any[]): void {\n      const startTimestamp = Date.now();\n\n      // open() should always be called with two or more arguments\n      // But to be on the safe side, we actually validate this and bail out if we don't have a method & url\n      const method = isString(args[0]) ? args[0].toUpperCase() : undefined;\n      const url = parseUrl(args[1]);\n\n      if (!method || !url) {\n        return originalOpen.apply(this, args);\n      }\n\n      this[SENTRY_XHR_DATA_KEY] = {\n        method,\n        url,\n        request_headers: {},\n      };\n\n      // if Sentry key appears in URL, don't capture it as a request\n      if (method === 'POST' && url.match(/sentry_key/)) {\n        this.__sentry_own_request__ = true;\n      }\n\n      const onreadystatechangeHandler: () => void = () => {\n        // For whatever reason, this is not the same instance here as from the outer method\n        const xhrInfo = this[SENTRY_XHR_DATA_KEY];\n\n        if (!xhrInfo) {\n          return;\n        }\n\n        if (this.readyState === 4) {\n          try {\n            // touching statusCode in some platforms throws\n            // an exception\n            xhrInfo.status_code = this.status;\n          } catch (e) {\n            /* do nothing */\n          }\n\n          const handlerData: HandlerDataXhr = {\n            args: [method, url],\n            endTimestamp: Date.now(),\n            startTimestamp,\n            xhr: this,\n          };\n          triggerHandlers('xhr', handlerData);\n        }\n      };\n\n      if ('onreadystatechange' in this && typeof this.onreadystatechange === 'function') {\n        fill(this, 'onreadystatechange', function (original: WrappedFunction): Function {\n          return function (this: SentryWrappedXMLHttpRequest, ...readyStateArgs: any[]): void {\n            onreadystatechangeHandler();\n            return original.apply(this, readyStateArgs);\n          };\n        });\n      } else {\n        this.addEventListener('readystatechange', onreadystatechangeHandler);\n      }\n\n      // Intercepting `setRequestHeader` to access the request headers of XHR instance.\n      // This will only work for user/library defined headers, not for the default/browser-assigned headers.\n      // Request cookies are also unavailable for XHR, as `Cookie` header can't be defined by `setRequestHeader`.\n      fill(this, 'setRequestHeader', function (original: WrappedFunction): Function {\n        return function (this: SentryWrappedXMLHttpRequest, ...setRequestHeaderArgs: unknown[]): void {\n          const [header, value] = setRequestHeaderArgs;\n\n          const xhrInfo = this[SENTRY_XHR_DATA_KEY];\n\n          if (xhrInfo && isString(header) && isString(value)) {\n            xhrInfo.request_headers[header.toLowerCase()] = value;\n          }\n\n          return original.apply(this, setRequestHeaderArgs);\n        };\n      });\n\n      return originalOpen.apply(this, args);\n    };\n  });\n\n  fill(xhrproto, 'send', function (originalSend: () => void): () => void {\n    return function (this: XMLHttpRequest & SentryWrappedXMLHttpRequest, ...args: any[]): void {\n      const sentryXhrData = this[SENTRY_XHR_DATA_KEY];\n\n      if (!sentryXhrData) {\n        return originalSend.apply(this, args);\n      }\n\n      if (args[0] !== undefined) {\n        sentryXhrData.body = args[0];\n      }\n\n      const handlerData: HandlerDataXhr = {\n        args: [sentryXhrData.method, sentryXhrData.url],\n        startTimestamp: Date.now(),\n        xhr: this,\n      };\n      triggerHandlers('xhr', handlerData);\n\n      return originalSend.apply(this, args);\n    };\n  });\n}\n\nfunction parseUrl(url: string | unknown): string | undefined {\n  if (isString(url)) {\n    return url;\n  }\n\n  try {\n    // url can be a string or URL\n    // but since URL is not available in IE11, we do not check for it,\n    // but simply assume it is an URL and return `toString()` from it (which returns the full URL)\n    // If that fails, we just return undefined\n    return (url as URL).toString();\n  } catch {} // eslint-disable-line no-empty\n\n  return undefined;\n}\n"],"mappings":";;;;AAWA,MAAMA,MAAA,GAASC,UAAW;AAEnB,MAAMC,mBAAoB,GAAE;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,4BAA4BA,CAACC,OAAO,EAAwC;EAC1F,MAAMC,IAAK,GAAE,KAAK;EAClBC,UAAU,CAACD,IAAI,EAAED,OAAO,CAAC;EACzBG,eAAe,CAACF,IAAI,EAAEG,aAAa,CAAC;AACtC;;AAEA;AACO,SAASA,aAAaA,CAAA,EAAS;EACtC;EACE,IAAI,CAAER,MAAA,CAAeS,cAAc,EAAE;IACnC;EACJ;EAEE,MAAMC,QAAA,GAAWD,cAAc,CAACE,SAAS;EAEzCC,IAAI,CAACF,QAAQ,EAAE,MAAM,EAAE,UAAUG,YAAY,EAA0B;IACrE,OAAO,YAAoF;MACzF,MAAMC,cAAe,GAAEC,IAAI,CAACC,GAAG,EAAE;;MAEvC;MACA;MAAA,SAAAC,IAAA,GAAAC,SAAA,CAAAC,MAAA,EAJ4EC,IAAI,OAAAC,KAAA,CAAAJ,IAAA,GAAAK,IAAA,MAAAA,IAAA,GAAAL,IAAA,EAAAK,IAAA;QAAJF,IAAI,CAAAE,IAAA,IAAAJ,SAAA,CAAAI,IAAA;MAAA;MAK1E,MAAMC,MAAA,GAASC,QAAQ,CAACJ,IAAI,CAAC,CAAC,CAAC,IAAIA,IAAI,CAAC,CAAC,CAAC,CAACK,WAAW,EAAC,GAAIC,SAAS;MACpE,MAAMC,GAAA,GAAMC,QAAQ,CAACR,IAAI,CAAC,CAAC,CAAC,CAAC;MAE7B,IAAI,CAACG,MAAA,IAAU,CAACI,GAAG,EAAE;QACnB,OAAOd,YAAY,CAACgB,KAAK,CAAC,IAAI,EAAET,IAAI,CAAC;MAC7C;MAEM,IAAI,CAAClB,mBAAmB,IAAI;QAC1BqB,MAAM;QACNI,GAAG;QACHG,eAAe,EAAE;MACzB,CAAO;;MAEP;MACM,IAAIP,MAAO,KAAI,MAAO,IAAGI,GAAG,CAACI,KAAK,CAAC,YAAY,CAAC,EAAE;QAChD,IAAI,CAACC,sBAAuB,GAAE,IAAI;MAC1C;MAEM,MAAMC,yBAAyB,GAAeA,CAAA,KAAM;QAC1D;QACQ,MAAMC,OAAQ,GAAE,IAAI,CAAChC,mBAAmB,CAAC;QAEzC,IAAI,CAACgC,OAAO,EAAE;UACZ;QACV;QAEQ,IAAI,IAAI,CAACC,UAAW,KAAI,CAAC,EAAE;UACzB,IAAI;YACd;YACA;YACYD,OAAO,CAACE,WAAA,GAAc,IAAI,CAACC,MAAM;UAC7C,CAAY,QAAOC,CAAC,EAAE;YACtB;UAAA;UAGU,MAAMC,WAAW,GAAmB;YAClCnB,IAAI,EAAE,CAACG,MAAM,EAAEI,GAAG,CAAC;YACnBa,YAAY,EAAEzB,IAAI,CAACC,GAAG,EAAE;YACxBF,cAAc;YACd2B,GAAG,EAAE;UACjB,CAAW;UACDC,eAAe,CAAC,KAAK,EAAEH,WAAW,CAAC;QAC7C;MACA,CAAO;MAED,IAAI,oBAAqB,IAAG,IAAK,IAAG,OAAO,IAAI,CAACI,kBAAA,KAAuB,UAAU,EAAE;QACjF/B,IAAI,CAAC,IAAI,EAAE,oBAAoB,EAAE,UAAUgC,QAAQ,EAA6B;UAC9E,OAAO,YAA6E;YAClFX,yBAAyB,EAAE;YAAA,SAAAY,KAAA,GAAA3B,SAAA,CAAAC,MAAA,EAD0B2B,cAAc,OAAAzB,KAAA,CAAAwB,KAAA,GAAAE,KAAA,MAAAA,KAAA,GAAAF,KAAA,EAAAE,KAAA;cAAdD,cAAc,CAAAC,KAAA,IAAA7B,SAAA,CAAA6B,KAAA;YAAA;YAEnE,OAAOH,QAAQ,CAACf,KAAK,CAAC,IAAI,EAAEiB,cAAc,CAAC;UACvD,CAAW;QACX,CAAS,CAAC;MACV,OAAa;QACL,IAAI,CAACE,gBAAgB,CAAC,kBAAkB,EAAEf,yBAAyB,CAAC;MAC5E;;MAEA;MACA;MACA;MACMrB,IAAI,CAAC,IAAI,EAAE,kBAAkB,EAAE,UAAUgC,QAAQ,EAA6B;QAC5E,OAAO,YAAuF;UAAA,SAAAK,KAAA,GAAA/B,SAAA,CAAAC,MAAA,EAAvC+B,oBAAoB,OAAA7B,KAAA,CAAA4B,KAAA,GAAAE,KAAA,MAAAA,KAAA,GAAAF,KAAA,EAAAE,KAAA;YAApBD,oBAAoB,CAAAC,KAAA,IAAAjC,SAAA,CAAAiC,KAAA;UAAA;UACzE,MAAM,CAACC,MAAM,EAAEC,KAAK,IAAIH,oBAAoB;UAE5C,MAAMhB,OAAQ,GAAE,IAAI,CAAChC,mBAAmB,CAAC;UAEzC,IAAIgC,OAAQ,IAAGV,QAAQ,CAAC4B,MAAM,KAAK5B,QAAQ,CAAC6B,KAAK,CAAC,EAAE;YAClDnB,OAAO,CAACJ,eAAe,CAACsB,MAAM,CAACE,WAAW,EAAE,CAAE,GAAED,KAAK;UACjE;UAEU,OAAOT,QAAQ,CAACf,KAAK,CAAC,IAAI,EAAEqB,oBAAoB,CAAC;QAC3D,CAAS;MACT,CAAO,CAAC;MAEF,OAAOrC,YAAY,CAACgB,KAAK,CAAC,IAAI,EAAET,IAAI,CAAC;IAC3C,CAAK;EACL,CAAG,CAAC;EAEFR,IAAI,CAACF,QAAQ,EAAE,MAAM,EAAE,UAAU6C,YAAY,EAA0B;IACrE,OAAO,YAAoF;MACzF,MAAMC,aAAc,GAAE,IAAI,CAACtD,mBAAmB,CAAC;MAAA,SAAAuD,KAAA,GAAAvC,SAAA,CAAAC,MAAA,EADuBC,IAAI,OAAAC,KAAA,CAAAoC,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;QAAJtC,IAAI,CAAAsC,KAAA,IAAAxC,SAAA,CAAAwC,KAAA;MAAA;MAG1E,IAAI,CAACF,aAAa,EAAE;QAClB,OAAOD,YAAY,CAAC1B,KAAK,CAAC,IAAI,EAAET,IAAI,CAAC;MAC7C;MAEM,IAAIA,IAAI,CAAC,CAAC,CAAE,KAAIM,SAAS,EAAE;QACzB8B,aAAa,CAACG,IAAA,GAAOvC,IAAI,CAAC,CAAC,CAAC;MACpC;MAEM,MAAMmB,WAAW,GAAmB;QAClCnB,IAAI,EAAE,CAACoC,aAAa,CAACjC,MAAM,EAAEiC,aAAa,CAAC7B,GAAG,CAAC;QAC/Cb,cAAc,EAAEC,IAAI,CAACC,GAAG,EAAE;QAC1ByB,GAAG,EAAE;MACb,CAAO;MACDC,eAAe,CAAC,KAAK,EAAEH,WAAW,CAAC;MAEnC,OAAOgB,YAAY,CAAC1B,KAAK,CAAC,IAAI,EAAET,IAAI,CAAC;IAC3C,CAAK;EACL,CAAG,CAAC;AACJ;AAEA,SAASQ,QAAQA,CAACD,GAAG,EAAwC;EAC3D,IAAIH,QAAQ,CAACG,GAAG,CAAC,EAAE;IACjB,OAAOA,GAAG;EACd;EAEE,IAAI;IACN;IACA;IACA;IACA;IACI,OAAQA,GAAA,CAAYiC,QAAQ,EAAE;EAClC,CAAE,CAAE,OAAAC,EAAA,EAAM,EAAC;;EAET,OAAOnC,SAAS;AAClB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}