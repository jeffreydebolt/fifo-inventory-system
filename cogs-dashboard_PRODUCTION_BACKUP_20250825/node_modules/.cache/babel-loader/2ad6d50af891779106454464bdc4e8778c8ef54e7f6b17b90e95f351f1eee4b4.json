{"ast":null,"code":"import { defineIntegration, convertIntegrationFnToClass } from '@sentry/core';\nimport { fill, getFunctionName, getOriginalFunction } from '@sentry/utils';\nimport { WINDOW, wrap } from '../helpers.js';\nconst DEFAULT_EVENT_TARGET = ['EventTarget', 'Window', 'Node', 'ApplicationCache', 'AudioTrackList', 'BroadcastChannel', 'ChannelMergerNode', 'CryptoOperation', 'EventSource', 'FileReader', 'HTMLUnknownElement', 'IDBDatabase', 'IDBRequest', 'IDBTransaction', 'KeyOperation', 'MediaController', 'MessagePort', 'ModalWindow', 'Notification', 'SVGElementInstance', 'Screen', 'SharedWorker', 'TextTrack', 'TextTrackCue', 'TextTrackList', 'WebSocket', 'WebSocketWorker', 'Worker', 'XMLHttpRequest', 'XMLHttpRequestEventTarget', 'XMLHttpRequestUpload'];\nconst INTEGRATION_NAME = 'TryCatch';\nconst _browserApiErrorsIntegration = function () {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const _options = {\n    XMLHttpRequest: true,\n    eventTarget: true,\n    requestAnimationFrame: true,\n    setInterval: true,\n    setTimeout: true,\n    ...options\n  };\n  return {\n    name: INTEGRATION_NAME,\n    // TODO: This currently only works for the first client this is setup\n    // We may want to adjust this to check for client etc.\n    setupOnce() {\n      if (_options.setTimeout) {\n        fill(WINDOW, 'setTimeout', _wrapTimeFunction);\n      }\n      if (_options.setInterval) {\n        fill(WINDOW, 'setInterval', _wrapTimeFunction);\n      }\n      if (_options.requestAnimationFrame) {\n        fill(WINDOW, 'requestAnimationFrame', _wrapRAF);\n      }\n      if (_options.XMLHttpRequest && 'XMLHttpRequest' in WINDOW) {\n        fill(XMLHttpRequest.prototype, 'send', _wrapXHR);\n      }\n      const eventTargetOption = _options.eventTarget;\n      if (eventTargetOption) {\n        const eventTarget = Array.isArray(eventTargetOption) ? eventTargetOption : DEFAULT_EVENT_TARGET;\n        eventTarget.forEach(_wrapEventTarget);\n      }\n    }\n  };\n};\nconst browserApiErrorsIntegration = defineIntegration(_browserApiErrorsIntegration);\n\n/**\n * Wrap timer functions and event targets to catch errors and provide better meta data.\n * @deprecated Use `browserApiErrorsIntegration()` instead.\n */\n// eslint-disable-next-line deprecation/deprecation\nconst TryCatch = convertIntegrationFnToClass(INTEGRATION_NAME, browserApiErrorsIntegration);\nfunction _wrapTimeFunction(original) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    const originalCallback = args[0];\n    args[0] = wrap(originalCallback, {\n      mechanism: {\n        data: {\n          function: getFunctionName(original)\n        },\n        handled: false,\n        type: 'instrument'\n      }\n    });\n    return original.apply(this, args);\n  };\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _wrapRAF(original) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return function (callback) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    return original.apply(this, [wrap(callback, {\n      mechanism: {\n        data: {\n          function: 'requestAnimationFrame',\n          handler: getFunctionName(original)\n        },\n        handled: false,\n        type: 'instrument'\n      }\n    })]);\n  };\n}\nfunction _wrapXHR(originalSend) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return function () {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const xhr = this;\n    const xmlHttpRequestProps = ['onload', 'onerror', 'onprogress', 'onreadystatechange'];\n    xmlHttpRequestProps.forEach(prop => {\n      if (prop in xhr && typeof xhr[prop] === 'function') {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        fill(xhr, prop, function (original) {\n          const wrapOptions = {\n            mechanism: {\n              data: {\n                function: prop,\n                handler: getFunctionName(original)\n              },\n              handled: false,\n              type: 'instrument'\n            }\n          };\n\n          // If Instrument integration has been called before TryCatch, get the name of original function\n          const originalFunction = getOriginalFunction(original);\n          if (originalFunction) {\n            wrapOptions.mechanism.data.handler = getFunctionName(originalFunction);\n          }\n\n          // Otherwise wrap directly\n          return wrap(original, wrapOptions);\n        });\n      }\n    });\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    return originalSend.apply(this, args);\n  };\n}\nfunction _wrapEventTarget(target) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const globalObject = WINDOW;\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  const proto = globalObject[target] && globalObject[target].prototype;\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, no-prototype-builtins\n  if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {\n    return;\n  }\n  fill(proto, 'addEventListener', function (original) {\n    return function (\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    eventName, fn, options) {\n      try {\n        if (typeof fn.handleEvent === 'function') {\n          // ESlint disable explanation:\n          //  First, it is generally safe to call `wrap` with an unbound function. Furthermore, using `.bind()` would\n          //  introduce a bug here, because bind returns a new function that doesn't have our\n          //  flags(like __sentry_original__) attached. `wrap` checks for those flags to avoid unnecessary wrapping.\n          //  Without those flags, every call to addEventListener wraps the function again, causing a memory leak.\n          // eslint-disable-next-line @typescript-eslint/unbound-method\n          fn.handleEvent = wrap(fn.handleEvent, {\n            mechanism: {\n              data: {\n                function: 'handleEvent',\n                handler: getFunctionName(fn),\n                target\n              },\n              handled: false,\n              type: 'instrument'\n            }\n          });\n        }\n      } catch (err) {\n        // can sometimes get 'Permission denied to access property \"handle Event'\n      }\n      return original.apply(this, [eventName,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      wrap(fn, {\n        mechanism: {\n          data: {\n            function: 'addEventListener',\n            handler: getFunctionName(fn),\n            target\n          },\n          handled: false,\n          type: 'instrument'\n        }\n      }), options]);\n    };\n  });\n  fill(proto, 'removeEventListener', function (originalRemoveEventListener\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ) {\n    return function (\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    eventName, fn, options) {\n      /**\n       * There are 2 possible scenarios here:\n       *\n       * 1. Someone passes a callback, which was attached prior to Sentry initialization, or by using unmodified\n       * method, eg. `document.addEventListener.call(el, name, handler). In this case, we treat this function\n       * as a pass-through, and call original `removeEventListener` with it.\n       *\n       * 2. Someone passes a callback, which was attached after Sentry was initialized, which means that it was using\n       * our wrapped version of `addEventListener`, which internally calls `wrap` helper.\n       * This helper \"wraps\" whole callback inside a try/catch statement, and attached appropriate metadata to it,\n       * in order for us to make a distinction between wrapped/non-wrapped functions possible.\n       * If a function was wrapped, it has additional property of `__sentry_wrapped__`, holding the handler.\n       *\n       * When someone adds a handler prior to initialization, and then do it again, but after,\n       * then we have to detach both of them. Otherwise, if we'd detach only wrapped one, it'd be impossible\n       * to get rid of the initial handler and it'd stick there forever.\n       */\n      const wrappedEventHandler = fn;\n      try {\n        const originalEventHandler = wrappedEventHandler && wrappedEventHandler.__sentry_wrapped__;\n        if (originalEventHandler) {\n          originalRemoveEventListener.call(this, eventName, originalEventHandler, options);\n        }\n      } catch (e) {\n        // ignore, accessing __sentry_wrapped__ will throw in some Selenium environments\n      }\n      return originalRemoveEventListener.call(this, eventName, wrappedEventHandler, options);\n    };\n  });\n}\nexport { TryCatch, browserApiErrorsIntegration };","map":{"version":3,"names":["DEFAULT_EVENT_TARGET","INTEGRATION_NAME","_browserApiErrorsIntegration","options","arguments","length","undefined","_options","XMLHttpRequest","eventTarget","requestAnimationFrame","setInterval","setTimeout","name","setupOnce","fill","WINDOW","_wrapTimeFunction","_wrapRAF","prototype","_wrapXHR","eventTargetOption","Array","isArray","forEach","_wrapEventTarget","browserApiErrorsIntegration","defineIntegration","TryCatch","convertIntegrationFnToClass","original","_len","args","_key","originalCallback","wrap","mechanism","data","function","getFunctionName","handled","type","apply","callback","handler","originalSend","xhr","xmlHttpRequestProps","prop","wrapOptions","originalFunction","getOriginalFunction","_len2","_key2","target","globalObject","proto","hasOwnProperty","eventName","fn","handleEvent","err","originalRemoveEventListener","wrappedEventHandler","originalEventHandler","__sentry_wrapped__","call","e"],"sources":["/Users/jeffreydebolt/Documents/fifo/cogs-dashboard/node_modules/src/integrations/trycatch.ts"],"sourcesContent":["import { convertIntegrationFnToClass, defineIntegration } from '@sentry/core';\nimport type { Integration, IntegrationClass, IntegrationFn, WrappedFunction } from '@sentry/types';\nimport { fill, getFunctionName, getOriginalFunction } from '@sentry/utils';\n\nimport { WINDOW, wrap } from '../helpers';\n\nconst DEFAULT_EVENT_TARGET = [\n  'EventTarget',\n  'Window',\n  'Node',\n  'ApplicationCache',\n  'AudioTrackList',\n  'BroadcastChannel',\n  'ChannelMergerNode',\n  'CryptoOperation',\n  'EventSource',\n  'FileReader',\n  'HTMLUnknownElement',\n  'IDBDatabase',\n  'IDBRequest',\n  'IDBTransaction',\n  'KeyOperation',\n  'MediaController',\n  'MessagePort',\n  'ModalWindow',\n  'Notification',\n  'SVGElementInstance',\n  'Screen',\n  'SharedWorker',\n  'TextTrack',\n  'TextTrackCue',\n  'TextTrackList',\n  'WebSocket',\n  'WebSocketWorker',\n  'Worker',\n  'XMLHttpRequest',\n  'XMLHttpRequestEventTarget',\n  'XMLHttpRequestUpload',\n];\n\nconst INTEGRATION_NAME = 'TryCatch';\n\ntype XMLHttpRequestProp = 'onload' | 'onerror' | 'onprogress' | 'onreadystatechange';\n\ninterface TryCatchOptions {\n  setTimeout: boolean;\n  setInterval: boolean;\n  requestAnimationFrame: boolean;\n  XMLHttpRequest: boolean;\n  eventTarget: boolean | string[];\n}\n\nconst _browserApiErrorsIntegration = ((options: Partial<TryCatchOptions> = {}) => {\n  const _options = {\n    XMLHttpRequest: true,\n    eventTarget: true,\n    requestAnimationFrame: true,\n    setInterval: true,\n    setTimeout: true,\n    ...options,\n  };\n\n  return {\n    name: INTEGRATION_NAME,\n    // TODO: This currently only works for the first client this is setup\n    // We may want to adjust this to check for client etc.\n    setupOnce() {\n      if (_options.setTimeout) {\n        fill(WINDOW, 'setTimeout', _wrapTimeFunction);\n      }\n\n      if (_options.setInterval) {\n        fill(WINDOW, 'setInterval', _wrapTimeFunction);\n      }\n\n      if (_options.requestAnimationFrame) {\n        fill(WINDOW, 'requestAnimationFrame', _wrapRAF);\n      }\n\n      if (_options.XMLHttpRequest && 'XMLHttpRequest' in WINDOW) {\n        fill(XMLHttpRequest.prototype, 'send', _wrapXHR);\n      }\n\n      const eventTargetOption = _options.eventTarget;\n      if (eventTargetOption) {\n        const eventTarget = Array.isArray(eventTargetOption) ? eventTargetOption : DEFAULT_EVENT_TARGET;\n        eventTarget.forEach(_wrapEventTarget);\n      }\n    },\n  };\n}) satisfies IntegrationFn;\n\nexport const browserApiErrorsIntegration = defineIntegration(_browserApiErrorsIntegration);\n\n/**\n * Wrap timer functions and event targets to catch errors and provide better meta data.\n * @deprecated Use `browserApiErrorsIntegration()` instead.\n */\n// eslint-disable-next-line deprecation/deprecation\nexport const TryCatch = convertIntegrationFnToClass(\n  INTEGRATION_NAME,\n  browserApiErrorsIntegration,\n) as IntegrationClass<Integration> & {\n  new (options?: {\n    setTimeout: boolean;\n    setInterval: boolean;\n    requestAnimationFrame: boolean;\n    XMLHttpRequest: boolean;\n    eventTarget: boolean | string[];\n  }): Integration;\n};\n\nfunction _wrapTimeFunction(original: () => void): () => number {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return function (this: any, ...args: any[]): number {\n    const originalCallback = args[0];\n    args[0] = wrap(originalCallback, {\n      mechanism: {\n        data: { function: getFunctionName(original) },\n        handled: false,\n        type: 'instrument',\n      },\n    });\n    return original.apply(this, args);\n  };\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _wrapRAF(original: any): (callback: () => void) => any {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return function (this: any, callback: () => void): () => void {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    return original.apply(this, [\n      wrap(callback, {\n        mechanism: {\n          data: {\n            function: 'requestAnimationFrame',\n            handler: getFunctionName(original),\n          },\n          handled: false,\n          type: 'instrument',\n        },\n      }),\n    ]);\n  };\n}\n\nfunction _wrapXHR(originalSend: () => void): () => void {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return function (this: XMLHttpRequest, ...args: any[]): void {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const xhr = this;\n    const xmlHttpRequestProps: XMLHttpRequestProp[] = ['onload', 'onerror', 'onprogress', 'onreadystatechange'];\n\n    xmlHttpRequestProps.forEach(prop => {\n      if (prop in xhr && typeof xhr[prop] === 'function') {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        fill(xhr, prop, function (original: WrappedFunction): () => any {\n          const wrapOptions = {\n            mechanism: {\n              data: {\n                function: prop,\n                handler: getFunctionName(original),\n              },\n              handled: false,\n              type: 'instrument',\n            },\n          };\n\n          // If Instrument integration has been called before TryCatch, get the name of original function\n          const originalFunction = getOriginalFunction(original);\n          if (originalFunction) {\n            wrapOptions.mechanism.data.handler = getFunctionName(originalFunction);\n          }\n\n          // Otherwise wrap directly\n          return wrap(original, wrapOptions);\n        });\n      }\n    });\n\n    return originalSend.apply(this, args);\n  };\n}\n\nfunction _wrapEventTarget(target: string): void {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const globalObject = WINDOW as { [key: string]: any };\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  const proto = globalObject[target] && globalObject[target].prototype;\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, no-prototype-builtins\n  if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {\n    return;\n  }\n\n  fill(proto, 'addEventListener', function (original: VoidFunction,): (\n    eventName: string,\n    fn: EventListenerObject,\n    options?: boolean | AddEventListenerOptions,\n  ) => void {\n    return function (\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      this: any,\n      eventName: string,\n      fn: EventListenerObject,\n      options?: boolean | AddEventListenerOptions,\n    ): (eventName: string, fn: EventListenerObject, capture?: boolean, secure?: boolean) => void {\n      try {\n        if (typeof fn.handleEvent === 'function') {\n          // ESlint disable explanation:\n          //  First, it is generally safe to call `wrap` with an unbound function. Furthermore, using `.bind()` would\n          //  introduce a bug here, because bind returns a new function that doesn't have our\n          //  flags(like __sentry_original__) attached. `wrap` checks for those flags to avoid unnecessary wrapping.\n          //  Without those flags, every call to addEventListener wraps the function again, causing a memory leak.\n          // eslint-disable-next-line @typescript-eslint/unbound-method\n          fn.handleEvent = wrap(fn.handleEvent, {\n            mechanism: {\n              data: {\n                function: 'handleEvent',\n                handler: getFunctionName(fn),\n                target,\n              },\n              handled: false,\n              type: 'instrument',\n            },\n          });\n        }\n      } catch (err) {\n        // can sometimes get 'Permission denied to access property \"handle Event'\n      }\n\n      return original.apply(this, [\n        eventName,\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        wrap(fn as any as WrappedFunction, {\n          mechanism: {\n            data: {\n              function: 'addEventListener',\n              handler: getFunctionName(fn),\n              target,\n            },\n            handled: false,\n            type: 'instrument',\n          },\n        }),\n        options,\n      ]);\n    };\n  });\n\n  fill(\n    proto,\n    'removeEventListener',\n    function (\n      originalRemoveEventListener: () => void,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ): (this: any, eventName: string, fn: EventListenerObject, options?: boolean | EventListenerOptions) => () => void {\n      return function (\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this: any,\n        eventName: string,\n        fn: EventListenerObject,\n        options?: boolean | EventListenerOptions,\n      ): () => void {\n        /**\n         * There are 2 possible scenarios here:\n         *\n         * 1. Someone passes a callback, which was attached prior to Sentry initialization, or by using unmodified\n         * method, eg. `document.addEventListener.call(el, name, handler). In this case, we treat this function\n         * as a pass-through, and call original `removeEventListener` with it.\n         *\n         * 2. Someone passes a callback, which was attached after Sentry was initialized, which means that it was using\n         * our wrapped version of `addEventListener`, which internally calls `wrap` helper.\n         * This helper \"wraps\" whole callback inside a try/catch statement, and attached appropriate metadata to it,\n         * in order for us to make a distinction between wrapped/non-wrapped functions possible.\n         * If a function was wrapped, it has additional property of `__sentry_wrapped__`, holding the handler.\n         *\n         * When someone adds a handler prior to initialization, and then do it again, but after,\n         * then we have to detach both of them. Otherwise, if we'd detach only wrapped one, it'd be impossible\n         * to get rid of the initial handler and it'd stick there forever.\n         */\n        const wrappedEventHandler = fn as unknown as WrappedFunction;\n        try {\n          const originalEventHandler = wrappedEventHandler && wrappedEventHandler.__sentry_wrapped__;\n          if (originalEventHandler) {\n            originalRemoveEventListener.call(this, eventName, originalEventHandler, options);\n          }\n        } catch (e) {\n          // ignore, accessing __sentry_wrapped__ will throw in some Selenium environments\n        }\n        return originalRemoveEventListener.call(this, eventName, wrappedEventHandler, options);\n      };\n    },\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}