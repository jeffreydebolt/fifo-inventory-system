{"ast":null,"code":"import { startInactiveSpan } from '@sentry/browser';\nimport { withActiveSpan, spanToJSON } from '@sentry/core';\nimport { timestampInSeconds } from '@sentry/utils';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nimport * as React from 'react';\nimport { REACT_MOUNT_OP, REACT_UPDATE_OP, REACT_RENDER_OP } from './constants.js';\nconst _jsxFileName = \"/home/runner/work/sentry-javascript/sentry-javascript/packages/react/src/profiler.tsx\";\nconst UNKNOWN_COMPONENT = 'unknown';\n\n/**\n * The Profiler component leverages Sentry's Tracing integration to generate\n * spans based on component lifecycles.\n */\nclass Profiler extends React.Component {\n  /**\n   * The span of the mount activity\n   * Made protected for the React Native SDK to access\n   */\n\n  /**\n   * The span that represents the duration of time between shouldComponentUpdate and componentDidUpdate\n   */\n\n  // eslint-disable-next-line @typescript-eslint/member-ordering\n  static __initStatic() {\n    this.defaultProps = {\n      disabled: false,\n      includeRender: true,\n      includeUpdates: true\n    };\n  }\n  constructor(props) {\n    super(props);\n    const {\n      name,\n      disabled = false\n    } = this.props;\n    if (disabled) {\n      return;\n    }\n    this._mountSpan = startInactiveSpan({\n      name: `<${name}>`,\n      onlyIfParent: true,\n      op: REACT_MOUNT_OP,\n      origin: 'auto.ui.react.profiler',\n      attributes: {\n        'ui.component_name': name\n      }\n    });\n  }\n\n  // If a component mounted, we can finish the mount activity.\n  componentDidMount() {\n    if (this._mountSpan) {\n      this._mountSpan.end();\n    }\n  }\n  shouldComponentUpdate(_ref) {\n    let {\n      updateProps,\n      includeUpdates = true\n    } = _ref;\n    // Only generate an update span if includeUpdates is true, if there is a valid mountSpan,\n    // and if the updateProps have changed. It is ok to not do a deep equality check here as it is expensive.\n    // We are just trying to give baseline clues for further investigation.\n    if (includeUpdates && this._mountSpan && updateProps !== this.props.updateProps) {\n      // See what props haved changed between the previous props, and the current props. This is\n      // set as data on the span. We just store the prop keys as the values could be potenially very large.\n      const changedProps = Object.keys(updateProps).filter(k => updateProps[k] !== this.props.updateProps[k]);\n      if (changedProps.length > 0) {\n        const now = timestampInSeconds();\n        this._updateSpan = withActiveSpan(this._mountSpan, () => {\n          return startInactiveSpan({\n            name: `<${this.props.name}>`,\n            onlyIfParent: true,\n            op: REACT_UPDATE_OP,\n            origin: 'auto.ui.react.profiler',\n            startTimestamp: now,\n            attributes: {\n              'ui.component_name': this.props.name,\n              'ui.react.changed_props': changedProps\n            }\n          });\n        });\n      }\n    }\n    return true;\n  }\n  componentDidUpdate() {\n    if (this._updateSpan) {\n      this._updateSpan.end();\n      this._updateSpan = undefined;\n    }\n  }\n\n  // If a component is unmounted, we can say it is no longer on the screen.\n  // This means we can finish the span representing the component render.\n  componentWillUnmount() {\n    const endTimestamp = timestampInSeconds();\n    const {\n      name,\n      includeRender = true\n    } = this.props;\n    if (this._mountSpan && includeRender) {\n      const startTimestamp = spanToJSON(this._mountSpan).timestamp;\n      withActiveSpan(this._mountSpan, () => {\n        const renderSpan = startInactiveSpan({\n          onlyIfParent: true,\n          name: `<${name}>`,\n          op: REACT_RENDER_OP,\n          origin: 'auto.ui.react.profiler',\n          startTimestamp,\n          attributes: {\n            'ui.component_name': name\n          }\n        });\n        if (renderSpan) {\n          // Have to cast to Span because the type of _mountSpan is Span | undefined\n          // and not getting narrowed properly\n          renderSpan.end(endTimestamp);\n        }\n      });\n    }\n  }\n  render() {\n    return this.props.children;\n  }\n}\nProfiler.__initStatic();\n\n/**\n * withProfiler is a higher order component that wraps a\n * component in a {@link Profiler} component. It is recommended that\n * the higher order component be used over the regular {@link Profiler} component.\n *\n * @param WrappedComponent component that is wrapped by Profiler\n * @param options the {@link ProfilerProps} you can pass into the Profiler\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction withProfiler(WrappedComponent,\n// We do not want to have `updateProps` given in options, it is instead filled through the HOC.\noptions) {\n  const componentDisplayName = options && options.name || WrappedComponent.displayName || WrappedComponent.name || UNKNOWN_COMPONENT;\n  const Wrapped = props => React.createElement(Profiler, {\n    ...options,\n    name: componentDisplayName,\n    updateProps: props,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 159\n    }\n  }, React.createElement(WrappedComponent, {\n    ...props,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 160\n    }\n  }));\n  Wrapped.displayName = `profiler(${componentDisplayName})`;\n\n  // Copy over static methods from Wrapped component to Profiler HOC\n  // See: https://reactjs.org/docs/higher-order-components.html#static-methods-must-be-copied-over\n  hoistNonReactStatics(Wrapped, WrappedComponent);\n  return Wrapped;\n}\n\n/**\n *\n * `useProfiler` is a React hook that profiles a React component.\n *\n * Requires React 16.8 or above.\n * @param name displayName of component being profiled\n */\nfunction useProfiler(name) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    disabled: false,\n    hasRenderSpan: true\n  };\n  const [mountSpan] = React.useState(() => {\n    if (options && options.disabled) {\n      return undefined;\n    }\n    return startInactiveSpan({\n      name: `<${name}>`,\n      onlyIfParent: true,\n      op: REACT_MOUNT_OP,\n      origin: 'auto.ui.react.profiler',\n      attributes: {\n        'ui.component_name': name\n      }\n    });\n  });\n  React.useEffect(() => {\n    if (mountSpan) {\n      mountSpan.end();\n    }\n    return () => {\n      if (mountSpan && options.hasRenderSpan) {\n        const startTimestamp = spanToJSON(mountSpan).timestamp;\n        const endTimestamp = timestampInSeconds();\n        const renderSpan = startInactiveSpan({\n          name: `<${name}>`,\n          onlyIfParent: true,\n          op: REACT_RENDER_OP,\n          origin: 'auto.ui.react.profiler',\n          startTimestamp,\n          attributes: {\n            'ui.component_name': name\n          }\n        });\n        if (renderSpan) {\n          // Have to cast to Span because the type of _mountSpan is Span | undefined\n          // and not getting narrowed properly\n          renderSpan.end(endTimestamp);\n        }\n      }\n    };\n    // We only want this to run once.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n}\nexport { Profiler, UNKNOWN_COMPONENT, useProfiler, withProfiler };","map":{"version":3,"names":["_jsxFileName","UNKNOWN_COMPONENT","Profiler","React","Component","__initStatic","defaultProps","disabled","includeRender","includeUpdates","constructor","props","name","_mountSpan","startInactiveSpan","onlyIfParent","op","REACT_MOUNT_OP","origin","attributes","componentDidMount","end","shouldComponentUpdate","_ref","updateProps","changedProps","Object","keys","filter","k","length","now","timestampInSeconds","_updateSpan","withActiveSpan","REACT_UPDATE_OP","startTimestamp","componentDidUpdate","undefined","componentWillUnmount","endTimestamp","spanToJSON","timestamp","renderSpan","REACT_RENDER_OP","render","children","withProfiler","WrappedComponent","options","componentDisplayName","displayName","Wrapped","createElement","__self","__source","fileName","lineNumber","hoistNonReactStatics","useProfiler","arguments","hasRenderSpan","mountSpan","useState","useEffect"],"sources":["/Users/jeffreydebolt/Documents/fifo/cogs-dashboard/node_modules/@sentry/src/profiler.tsx"],"sourcesContent":["import { startInactiveSpan } from '@sentry/browser';\nimport { spanToJSON, withActiveSpan } from '@sentry/core';\nimport type { Span } from '@sentry/types';\nimport { timestampInSeconds } from '@sentry/utils';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nimport * as React from 'react';\n\nimport { REACT_MOUNT_OP, REACT_RENDER_OP, REACT_UPDATE_OP } from './constants';\n\nexport const UNKNOWN_COMPONENT = 'unknown';\n\nexport type ProfilerProps = {\n  // The name of the component being profiled.\n  name: string;\n  // If the Profiler is disabled. False by default. This is useful if you want to disable profilers\n  // in certain environments.\n  disabled?: boolean;\n  // If time component is on page should be displayed as spans. True by default.\n  includeRender?: boolean;\n  // If component updates should be displayed as spans. True by default.\n  includeUpdates?: boolean;\n  // Component that is being profiled.\n  children?: React.ReactNode;\n  // props given to component being profiled.\n  updateProps: { [key: string]: unknown };\n};\n\n/**\n * The Profiler component leverages Sentry's Tracing integration to generate\n * spans based on component lifecycles.\n */\nclass Profiler extends React.Component<ProfilerProps> {\n  /**\n   * The span of the mount activity\n   * Made protected for the React Native SDK to access\n   */\n  protected _mountSpan: Span | undefined;\n  /**\n   * The span that represents the duration of time between shouldComponentUpdate and componentDidUpdate\n   */\n  protected _updateSpan: Span | undefined;\n\n  // eslint-disable-next-line @typescript-eslint/member-ordering\n  public static defaultProps: Partial<ProfilerProps> = {\n    disabled: false,\n    includeRender: true,\n    includeUpdates: true,\n  };\n\n  public constructor(props: ProfilerProps) {\n    super(props);\n    const { name, disabled = false } = this.props;\n\n    if (disabled) {\n      return;\n    }\n\n    this._mountSpan = startInactiveSpan({\n      name: `<${name}>`,\n      onlyIfParent: true,\n      op: REACT_MOUNT_OP,\n      origin: 'auto.ui.react.profiler',\n      attributes: { 'ui.component_name': name },\n    });\n  }\n\n  // If a component mounted, we can finish the mount activity.\n  public componentDidMount(): void {\n    if (this._mountSpan) {\n      this._mountSpan.end();\n    }\n  }\n\n  public shouldComponentUpdate({ updateProps, includeUpdates = true }: ProfilerProps): boolean {\n    // Only generate an update span if includeUpdates is true, if there is a valid mountSpan,\n    // and if the updateProps have changed. It is ok to not do a deep equality check here as it is expensive.\n    // We are just trying to give baseline clues for further investigation.\n    if (includeUpdates && this._mountSpan && updateProps !== this.props.updateProps) {\n      // See what props haved changed between the previous props, and the current props. This is\n      // set as data on the span. We just store the prop keys as the values could be potenially very large.\n      const changedProps = Object.keys(updateProps).filter(k => updateProps[k] !== this.props.updateProps[k]);\n      if (changedProps.length > 0) {\n        const now = timestampInSeconds();\n        this._updateSpan = withActiveSpan(this._mountSpan, () => {\n          return startInactiveSpan({\n            name: `<${this.props.name}>`,\n            onlyIfParent: true,\n            op: REACT_UPDATE_OP,\n            origin: 'auto.ui.react.profiler',\n            startTimestamp: now,\n            attributes: {\n              'ui.component_name': this.props.name,\n              'ui.react.changed_props': changedProps,\n            },\n          });\n        });\n      }\n    }\n\n    return true;\n  }\n\n  public componentDidUpdate(): void {\n    if (this._updateSpan) {\n      this._updateSpan.end();\n      this._updateSpan = undefined;\n    }\n  }\n\n  // If a component is unmounted, we can say it is no longer on the screen.\n  // This means we can finish the span representing the component render.\n  public componentWillUnmount(): void {\n    const endTimestamp = timestampInSeconds();\n    const { name, includeRender = true } = this.props;\n\n    if (this._mountSpan && includeRender) {\n      const startTimestamp = spanToJSON(this._mountSpan).timestamp;\n      withActiveSpan(this._mountSpan, () => {\n        const renderSpan = startInactiveSpan({\n          onlyIfParent: true,\n          name: `<${name}>`,\n          op: REACT_RENDER_OP,\n          origin: 'auto.ui.react.profiler',\n          startTimestamp,\n          attributes: { 'ui.component_name': name },\n        });\n        if (renderSpan) {\n          // Have to cast to Span because the type of _mountSpan is Span | undefined\n          // and not getting narrowed properly\n          renderSpan.end(endTimestamp);\n        }\n      });\n    }\n  }\n\n  public render(): React.ReactNode {\n    return this.props.children;\n  }\n}\n\n/**\n * withProfiler is a higher order component that wraps a\n * component in a {@link Profiler} component. It is recommended that\n * the higher order component be used over the regular {@link Profiler} component.\n *\n * @param WrappedComponent component that is wrapped by Profiler\n * @param options the {@link ProfilerProps} you can pass into the Profiler\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction withProfiler<P extends Record<string, any>>(\n  WrappedComponent: React.ComponentType<P>,\n  // We do not want to have `updateProps` given in options, it is instead filled through the HOC.\n  options?: Pick<Partial<ProfilerProps>, Exclude<keyof ProfilerProps, 'updateProps' | 'children'>>,\n): React.FC<P> {\n  const componentDisplayName =\n    (options && options.name) || WrappedComponent.displayName || WrappedComponent.name || UNKNOWN_COMPONENT;\n\n  const Wrapped: React.FC<P> = (props: P) => (\n    <Profiler {...options} name={componentDisplayName} updateProps={props}>\n      <WrappedComponent {...props} />\n    </Profiler>\n  );\n\n  Wrapped.displayName = `profiler(${componentDisplayName})`;\n\n  // Copy over static methods from Wrapped component to Profiler HOC\n  // See: https://reactjs.org/docs/higher-order-components.html#static-methods-must-be-copied-over\n  hoistNonReactStatics(Wrapped, WrappedComponent);\n  return Wrapped;\n}\n\n/**\n *\n * `useProfiler` is a React hook that profiles a React component.\n *\n * Requires React 16.8 or above.\n * @param name displayName of component being profiled\n */\nfunction useProfiler(\n  name: string,\n  options: { disabled?: boolean; hasRenderSpan?: boolean } = {\n    disabled: false,\n    hasRenderSpan: true,\n  },\n): void {\n  const [mountSpan] = React.useState(() => {\n    if (options && options.disabled) {\n      return undefined;\n    }\n\n    return startInactiveSpan({\n      name: `<${name}>`,\n      onlyIfParent: true,\n      op: REACT_MOUNT_OP,\n      origin: 'auto.ui.react.profiler',\n      attributes: { 'ui.component_name': name },\n    });\n  });\n\n  React.useEffect(() => {\n    if (mountSpan) {\n      mountSpan.end();\n    }\n\n    return (): void => {\n      if (mountSpan && options.hasRenderSpan) {\n        const startTimestamp = spanToJSON(mountSpan).timestamp;\n        const endTimestamp = timestampInSeconds();\n\n        const renderSpan = startInactiveSpan({\n          name: `<${name}>`,\n          onlyIfParent: true,\n          op: REACT_RENDER_OP,\n          origin: 'auto.ui.react.profiler',\n          startTimestamp,\n          attributes: { 'ui.component_name': name },\n        });\n        if (renderSpan) {\n          // Have to cast to Span because the type of _mountSpan is Span | undefined\n          // and not getting narrowed properly\n          renderSpan.end(endTimestamp);\n        }\n      }\n    };\n    // We only want this to run once.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n}\n\nexport { withProfiler, Profiler, useProfiler };\n"],"mappings":";;;;;;AAAA,MAAAA,YAAA;AASO,MAAMC,iBAAkB,GAAE;;AAkBjC;AACA;AACA;AACA;AACA,MAAMC,QAAS,SAAQC,KAAK,CAACC,SAAS,CAAgB;EACtD;AACA;AACA;AACA;;EAEA;AACA;AACA;;EAGA;EACS,OAAAC,aAAA;IAAA,KAAOC,YAAY,GAA2B;MACnDC,QAAQ,EAAE,KAAK;MACfC,aAAa,EAAE,IAAI;MACnBC,cAAc,EAAE;IACpB;EAAG;EAEMC,WAAWA,CAACC,KAAK,EAAiB;IACvC,KAAK,CAACA,KAAK,CAAC;IACZ,MAAM;MAAEC,IAAI;MAAEL,QAAA,GAAW;IAAA,CAAQ,GAAE,IAAI,CAACI,KAAK;IAE7C,IAAIJ,QAAQ,EAAE;MACZ;IACN;IAEI,IAAI,CAACM,UAAW,GAAEC,iBAAiB,CAAC;MAClCF,IAAI,EAAE,IAAIA,IAAI,GAAG;MACjBG,YAAY,EAAE,IAAI;MAClBC,EAAE,EAAEC,cAAc;MAClBC,MAAM,EAAE,wBAAwB;MAChCC,UAAU,EAAE;QAAE,mBAAmB,EAAEP;MAAA;IACzC,CAAK,CAAC;EACN;;EAEA;EACSQ,iBAAiBA,CAAA,EAAS;IAC/B,IAAI,IAAI,CAACP,UAAU,EAAE;MACnB,IAAI,CAACA,UAAU,CAACQ,GAAG,EAAE;IAC3B;EACA;EAESC,qBAAqBA,CAAAC,IAAA,EAAiE;IAAA,IAAhE;MAAEC,WAAW;MAAEf,cAAA,GAAiB;IAAA,CAAM,GAAAc,IAAA;IACrE;IACA;IACA;IACI,IAAId,cAAe,IAAG,IAAI,CAACI,UAAA,IAAcW,WAAA,KAAgB,IAAI,CAACb,KAAK,CAACa,WAAW,EAAE;MACrF;MACA;MACM,MAAMC,YAAa,GAAEC,MAAM,CAACC,IAAI,CAACH,WAAW,CAAC,CAACI,MAAM,CAACC,CAAA,IAAKL,WAAW,CAACK,CAAC,CAAE,KAAI,IAAI,CAAClB,KAAK,CAACa,WAAW,CAACK,CAAC,CAAC,CAAC;MACvG,IAAIJ,YAAY,CAACK,MAAO,GAAE,CAAC,EAAE;QAC3B,MAAMC,GAAA,GAAMC,kBAAkB,EAAE;QAChC,IAAI,CAACC,WAAY,GAAEC,cAAc,CAAC,IAAI,CAACrB,UAAU,EAAE,MAAM;UACvD,OAAOC,iBAAiB,CAAC;YACvBF,IAAI,EAAE,IAAI,IAAI,CAACD,KAAK,CAACC,IAAI,GAAG;YAC5BG,YAAY,EAAE,IAAI;YAClBC,EAAE,EAAEmB,eAAe;YACnBjB,MAAM,EAAE,wBAAwB;YAChCkB,cAAc,EAAEL,GAAG;YACnBZ,UAAU,EAAE;cACV,mBAAmB,EAAE,IAAI,CAACR,KAAK,CAACC,IAAI;cACpC,wBAAwB,EAAEa;YACxC;UACA,CAAW,CAAC;QACZ,CAAS,CAAC;MACV;IACA;IAEI,OAAO,IAAI;EACf;EAESY,kBAAkBA,CAAA,EAAS;IAChC,IAAI,IAAI,CAACJ,WAAW,EAAE;MACpB,IAAI,CAACA,WAAW,CAACZ,GAAG,EAAE;MACtB,IAAI,CAACY,WAAY,GAAEK,SAAS;IAClC;EACA;;EAEA;EACA;EACSC,oBAAoBA,CAAA,EAAS;IAClC,MAAMC,YAAA,GAAeR,kBAAkB,EAAE;IACzC,MAAM;MAAEpB,IAAI;MAAEJ,aAAA,GAAgB;IAAA,CAAO,GAAE,IAAI,CAACG,KAAK;IAEjD,IAAI,IAAI,CAACE,UAAW,IAAGL,aAAa,EAAE;MACpC,MAAM4B,cAAe,GAAEK,UAAU,CAAC,IAAI,CAAC5B,UAAU,CAAC,CAAC6B,SAAS;MAC5DR,cAAc,CAAC,IAAI,CAACrB,UAAU,EAAE,MAAM;QACpC,MAAM8B,UAAA,GAAa7B,iBAAiB,CAAC;UACnCC,YAAY,EAAE,IAAI;UAClBH,IAAI,EAAE,IAAIA,IAAI,GAAG;UACjBI,EAAE,EAAE4B,eAAe;UACnB1B,MAAM,EAAE,wBAAwB;UAChCkB,cAAc;UACdjB,UAAU,EAAE;YAAE,mBAAmB,EAAEP;UAAA;QAC7C,CAAS,CAAC;QACF,IAAI+B,UAAU,EAAE;UACxB;UACA;UACUA,UAAU,CAACtB,GAAG,CAACmB,YAAY,CAAC;QACtC;MACA,CAAO,CAAC;IACR;EACA;EAESK,MAAMA,CAAA,EAAoB;IAC/B,OAAO,IAAI,CAAClC,KAAK,CAACmC,QAAQ;EAC9B;AACA;AAAA5C,QAAA,CAAAG,YAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS0C,YAAYA,CACnBC,gBAAgB;AAClB;AACEC,OAAO,EACM;EACb,MAAMC,oBAAqB,GACxBD,OAAQ,IAAGA,OAAO,CAACrC,IAAI,IAAKoC,gBAAgB,CAACG,WAAA,IAAeH,gBAAgB,CAACpC,IAAA,IAAQX,iBAAiB;EAEzG,MAAMmD,OAAO,GAAiBzC,KAAK,IACjCR,KAAC,CAAAkD,aAAA,CAAAnD,QAAA;IAAS,GAAI+C,OAAO;IAAErC,IAAI,EAACsC,oBAAqB;IAAE1B,WAAW,EAACb,KAAM;IAAC2C,MAAA;IAAAC,QAAA;MAAAC,QAAA,EAAAxD,YAAA;MAAAyD,UAAA;IAAA;EAAA,GACpEtD,KAAC,CAAAkD,aAAA,CAAAL,gBAAA;IAAiB,GAAIrC,KAAK;IAAA2C,MAAA;IAAAC,QAAA;MAAAC,QAAA,EAAAxD,YAAA;MAAAyD,UAAA;IAAA;EAAA,EACjC,CACG;EAEDL,OAAO,CAACD,WAAA,GAAc,YAAYD,oBAAoB,GAAG;;EAE3D;EACA;EACEQ,oBAAoB,CAACN,OAAO,EAAEJ,gBAAgB,CAAC;EAC/C,OAAOI,OAAO;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASO,WAAWA,CAClB/C,IAAI,EAKE;EAAA,IAJNqC,OAAO,GAAAW,SAAA,CAAA9B,MAAA,QAAA8B,SAAA,QAAAtB,SAAA,GAAAsB,SAAA,MAAoD;IACzDrD,QAAQ,EAAE,KAAK;IACfsD,aAAa,EAAE;EACnB,CAAG;EAED,MAAM,CAACC,SAAS,CAAE,GAAE3D,KAAK,CAAC4D,QAAQ,CAAC,MAAM;IACvC,IAAId,OAAA,IAAWA,OAAO,CAAC1C,QAAQ,EAAE;MAC/B,OAAO+B,SAAS;IACtB;IAEI,OAAOxB,iBAAiB,CAAC;MACvBF,IAAI,EAAE,IAAIA,IAAI,GAAG;MACjBG,YAAY,EAAE,IAAI;MAClBC,EAAE,EAAEC,cAAc;MAClBC,MAAM,EAAE,wBAAwB;MAChCC,UAAU,EAAE;QAAE,mBAAmB,EAAEP;MAAA;IACzC,CAAK,CAAC;EACN,CAAG,CAAC;EAEFT,KAAK,CAAC6D,SAAS,CAAC,MAAM;IACpB,IAAIF,SAAS,EAAE;MACbA,SAAS,CAACzC,GAAG,EAAE;IACrB;IAEI,OAAO,MAAY;MACjB,IAAIyC,SAAA,IAAab,OAAO,CAACY,aAAa,EAAE;QACtC,MAAMzB,cAAA,GAAiBK,UAAU,CAACqB,SAAS,CAAC,CAACpB,SAAS;QACtD,MAAMF,YAAA,GAAeR,kBAAkB,EAAE;QAEzC,MAAMW,UAAA,GAAa7B,iBAAiB,CAAC;UACnCF,IAAI,EAAE,IAAIA,IAAI,GAAG;UACjBG,YAAY,EAAE,IAAI;UAClBC,EAAE,EAAE4B,eAAe;UACnB1B,MAAM,EAAE,wBAAwB;UAChCkB,cAAc;UACdjB,UAAU,EAAE;YAAE,mBAAmB,EAAEP;UAAA;QAC7C,CAAS,CAAC;QACF,IAAI+B,UAAU,EAAE;UACxB;UACA;UACUA,UAAU,CAACtB,GAAG,CAACmB,YAAY,CAAC;QACtC;MACA;IACA,CAAK;IACL;IACA;EACA,CAAG,EAAE,EAAE,CAAC;AACR","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}