{"ast":null,"code":"import { fill } from '../object.js';\nimport '../debug-build.js';\nimport '../logger.js';\nimport { GLOBAL_OBJ } from '../worldwide.js';\nimport { supportsHistory } from '../vendor/supportsHistory.js';\nimport { addHandler, maybeInstrument, triggerHandlers } from './_handlers.js';\nconst WINDOW = GLOBAL_OBJ;\nlet lastHref;\n\n/**\n * Add an instrumentation handler for when a fetch request happens.\n * The handler function is called once when the request starts and once when it ends,\n * which can be identified by checking if it has an `endTimestamp`.\n *\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nfunction addHistoryInstrumentationHandler(handler) {\n  const type = 'history';\n  addHandler(type, handler);\n  maybeInstrument(type, instrumentHistory);\n}\nfunction instrumentHistory() {\n  if (!supportsHistory()) {\n    return;\n  }\n  const oldOnPopState = WINDOW.onpopstate;\n  WINDOW.onpopstate = function () {\n    const to = WINDOW.location.href;\n    // keep track of the current URL state, as we always receive only the updated state\n    const from = lastHref;\n    lastHref = to;\n    const handlerData = {\n      from,\n      to\n    };\n    triggerHandlers('history', handlerData);\n    if (oldOnPopState) {\n      // Apparently this can throw in Firefox when incorrectly implemented plugin is installed.\n      // https://github.com/getsentry/sentry-javascript/issues/3344\n      // https://github.com/bugsnag/bugsnag-js/issues/469\n      try {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        return oldOnPopState.apply(this, args);\n      } catch (_oO) {\n        // no-empty\n      }\n    }\n  };\n  function historyReplacementFunction(originalHistoryFunction) {\n    return function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      const url = args.length > 2 ? args[2] : undefined;\n      if (url) {\n        // coerce to string (this is what pushState does)\n        const from = lastHref;\n        const to = String(url);\n        // keep track of the current URL state, as we always receive only the updated state\n        lastHref = to;\n        const handlerData = {\n          from,\n          to\n        };\n        triggerHandlers('history', handlerData);\n      }\n      return originalHistoryFunction.apply(this, args);\n    };\n  }\n  fill(WINDOW.history, 'pushState', historyReplacementFunction);\n  fill(WINDOW.history, 'replaceState', historyReplacementFunction);\n}\nexport { addHistoryInstrumentationHandler };","map":{"version":3,"names":["WINDOW","GLOBAL_OBJ","lastHref","addHistoryInstrumentationHandler","handler","type","addHandler","maybeInstrument","instrumentHistory","supportsHistory","oldOnPopState","onpopstate","to","location","href","from","handlerData","triggerHandlers","_len","arguments","length","args","Array","_key","apply","_oO","historyReplacementFunction","originalHistoryFunction","_len2","_key2","url","undefined","String","fill","history"],"sources":["/Users/jeffreydebolt/Documents/fifo/cogs-dashboard/node_modules/@sentry/src/instrument/history.ts"],"sourcesContent":["// TODO(v8): Move everything in this file into the browser package. Nothing here is generic and we run risk of leaking browser types into non-browser packages.\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/ban-types */\nimport type { HandlerDataHistory } from '@sentry/types';\n\nimport { fill } from '../object';\nimport { supportsHistory } from '../supports';\nimport { GLOBAL_OBJ } from '../worldwide';\nimport { addHandler, maybeInstrument, triggerHandlers } from './_handlers';\n\nconst WINDOW = GLOBAL_OBJ as unknown as Window;\n\nlet lastHref: string | undefined;\n\n/**\n * Add an instrumentation handler for when a fetch request happens.\n * The handler function is called once when the request starts and once when it ends,\n * which can be identified by checking if it has an `endTimestamp`.\n *\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nexport function addHistoryInstrumentationHandler(handler: (data: HandlerDataHistory) => void): void {\n  const type = 'history';\n  addHandler(type, handler);\n  maybeInstrument(type, instrumentHistory);\n}\n\nfunction instrumentHistory(): void {\n  if (!supportsHistory()) {\n    return;\n  }\n\n  const oldOnPopState = WINDOW.onpopstate;\n  WINDOW.onpopstate = function (this: WindowEventHandlers, ...args: any[]): any {\n    const to = WINDOW.location.href;\n    // keep track of the current URL state, as we always receive only the updated state\n    const from = lastHref;\n    lastHref = to;\n    const handlerData: HandlerDataHistory = { from, to };\n    triggerHandlers('history', handlerData);\n    if (oldOnPopState) {\n      // Apparently this can throw in Firefox when incorrectly implemented plugin is installed.\n      // https://github.com/getsentry/sentry-javascript/issues/3344\n      // https://github.com/bugsnag/bugsnag-js/issues/469\n      try {\n        return oldOnPopState.apply(this, args);\n      } catch (_oO) {\n        // no-empty\n      }\n    }\n  };\n\n  function historyReplacementFunction(originalHistoryFunction: () => void): () => void {\n    return function (this: History, ...args: any[]): void {\n      const url = args.length > 2 ? args[2] : undefined;\n      if (url) {\n        // coerce to string (this is what pushState does)\n        const from = lastHref;\n        const to = String(url);\n        // keep track of the current URL state, as we always receive only the updated state\n        lastHref = to;\n        const handlerData: HandlerDataHistory = { from, to };\n        triggerHandlers('history', handlerData);\n      }\n      return originalHistoryFunction.apply(this, args);\n    };\n  }\n\n  fill(WINDOW.history, 'pushState', historyReplacementFunction);\n  fill(WINDOW.history, 'replaceState', historyReplacementFunction);\n}\n"],"mappings":";;;;;;AAWA,MAAMA,MAAA,GAASC,UAAW;AAE1B,IAAIC,QAAQ;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,gCAAgCA,CAACC,OAAO,EAA4C;EAClG,MAAMC,IAAK,GAAE,SAAS;EACtBC,UAAU,CAACD,IAAI,EAAED,OAAO,CAAC;EACzBG,eAAe,CAACF,IAAI,EAAEG,iBAAiB,CAAC;AAC1C;AAEA,SAASA,iBAAiBA,CAAA,EAAS;EACjC,IAAI,CAACC,eAAe,EAAE,EAAE;IACtB;EACJ;EAEE,MAAMC,aAAA,GAAgBV,MAAM,CAACW,UAAU;EACvCX,MAAM,CAACW,UAAA,GAAa,YAA0D;IAC5E,MAAMC,EAAG,GAAEZ,MAAM,CAACa,QAAQ,CAACC,IAAI;IACnC;IACI,MAAMC,IAAK,GAAEb,QAAQ;IACrBA,QAAA,GAAWU,EAAE;IACb,MAAMI,WAAW,GAAuB;MAAED,IAAI;MAAEH;IAAA,CAAI;IACpDK,eAAe,CAAC,SAAS,EAAED,WAAW,CAAC;IACvC,IAAIN,aAAa,EAAE;MACvB;MACA;MACA;MACM,IAAI;QAAA,SAAAQ,IAAA,GAAAC,SAAA,CAAAC,MAAA,EAXoDC,IAAI,OAAAC,KAAA,CAAAJ,IAAA,GAAAK,IAAA,MAAAA,IAAA,GAAAL,IAAA,EAAAK,IAAA;UAAJF,IAAI,CAAAE,IAAA,IAAAJ,SAAA,CAAAI,IAAA;QAAA;QAY1D,OAAOb,aAAa,CAACc,KAAK,CAAC,IAAI,EAAEH,IAAI,CAAC;MAC9C,CAAQ,QAAOI,GAAG,EAAE;QACpB;MAAA;IAEA;EACA,CAAG;EAED,SAASC,0BAA0BA,CAACC,uBAAuB,EAA0B;IACnF,OAAO,YAA+C;MAAA,SAAAC,KAAA,GAAAT,SAAA,CAAAC,MAAA,EAAnBC,IAAI,OAAAC,KAAA,CAAAM,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;QAAJR,IAAI,CAAAQ,KAAA,IAAAV,SAAA,CAAAU,KAAA;MAAA;MACrC,MAAMC,GAAA,GAAMT,IAAI,CAACD,MAAO,GAAE,CAAE,GAAEC,IAAI,CAAC,CAAC,IAAIU,SAAS;MACjD,IAAID,GAAG,EAAE;QACf;QACQ,MAAMf,IAAK,GAAEb,QAAQ;QACrB,MAAMU,EAAG,GAAEoB,MAAM,CAACF,GAAG,CAAC;QAC9B;QACQ5B,QAAA,GAAWU,EAAE;QACb,MAAMI,WAAW,GAAuB;UAAED,IAAI;UAAEH;QAAA,CAAI;QACpDK,eAAe,CAAC,SAAS,EAAED,WAAW,CAAC;MAC/C;MACM,OAAOW,uBAAuB,CAACH,KAAK,CAAC,IAAI,EAAEH,IAAI,CAAC;IACtD,CAAK;EACL;EAEEY,IAAI,CAACjC,MAAM,CAACkC,OAAO,EAAE,WAAW,EAAER,0BAA0B,CAAC;EAC7DO,IAAI,CAACjC,MAAM,CAACkC,OAAO,EAAE,cAAc,EAAER,0BAA0B,CAAC;AAClE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}