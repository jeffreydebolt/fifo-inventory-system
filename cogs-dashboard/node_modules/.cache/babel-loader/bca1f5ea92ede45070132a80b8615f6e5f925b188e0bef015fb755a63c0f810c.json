{"ast":null,"code":"import { logger, timestampInSeconds } from '@sentry/utils';\nimport { DEBUG_BUILD } from '../debug-build.js';\nimport { spanTimeInputToSeconds, spanToJSON } from '../utils/spanUtils.js';\nimport { SpanRecorder } from './span.js';\nimport { Transaction } from './transaction.js';\nconst TRACING_DEFAULTS = {\n  idleTimeout: 1000,\n  finalTimeout: 30000,\n  heartbeatInterval: 5000\n};\nconst FINISH_REASON_TAG = 'finishReason';\nconst IDLE_TRANSACTION_FINISH_REASONS = ['heartbeatFailed', 'idleTimeout', 'documentHidden', 'finalTimeout', 'externalFinish', 'cancelled'];\n\n/**\n * @inheritDoc\n */\nclass IdleTransactionSpanRecorder extends SpanRecorder {\n  constructor(_pushActivity, _popActivity, transactionSpanId, maxlen) {\n    super(maxlen);\n    this._pushActivity = _pushActivity;\n    this._popActivity = _popActivity;\n    this.transactionSpanId = transactionSpanId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  add(span) {\n    var _this = this;\n    // We should make sure we do not push and pop activities for\n    // the transaction that this span recorder belongs to.\n    if (span.spanContext().spanId !== this.transactionSpanId) {\n      // We patch span.end() to pop an activity after setting an endTimestamp.\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      const originalEnd = span.end;\n      span.end = function () {\n        _this._popActivity(span.spanContext().spanId);\n        for (var _len = arguments.length, rest = new Array(_len), _key = 0; _key < _len; _key++) {\n          rest[_key] = arguments[_key];\n        }\n        return originalEnd.apply(span, rest);\n      };\n\n      // We should only push new activities if the span does not have an end timestamp.\n      if (spanToJSON(span).timestamp === undefined) {\n        this._pushActivity(span.spanContext().spanId);\n      }\n    }\n    super.add(span);\n  }\n}\n\n/**\n * An IdleTransaction is a transaction that automatically finishes. It does this by tracking child spans as activities.\n * You can have multiple IdleTransactions active, but if the `onScope` option is specified, the idle transaction will\n * put itself on the scope on creation.\n */\nclass IdleTransaction extends Transaction {\n  // Activities store a list of active spans\n\n  // Track state of activities in previous heartbeat\n\n  // Amount of times heartbeat has counted. Will cause transaction to finish after 3 beats.\n\n  // We should not use heartbeat if we finished a transaction\n\n  // Idle timeout was canceled and we should finish the transaction with the last span end.\n\n  /**\n   * Timer that tracks Transaction idleTimeout\n   */\n\n  /**\n   * @deprecated Transactions will be removed in v8. Use spans instead.\n   */\n  constructor(transactionContext,\n  // eslint-disable-next-line deprecation/deprecation\n  _idleHub) {\n    let _idleTimeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TRACING_DEFAULTS.idleTimeout;\n    let _finalTimeout = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : TRACING_DEFAULTS.finalTimeout;\n    let _heartbeatInterval = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : TRACING_DEFAULTS.heartbeatInterval;\n    let _onScope = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    let delayAutoFinishUntilSignal = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    super(transactionContext, _idleHub);\n    this._idleHub = _idleHub;\n    this._idleTimeout = _idleTimeout;\n    this._finalTimeout = _finalTimeout;\n    this._heartbeatInterval = _heartbeatInterval;\n    this._onScope = _onScope;\n    this.activities = {};\n    this._heartbeatCounter = 0;\n    this._finished = false;\n    this._idleTimeoutCanceledPermanently = false;\n    this._beforeFinishCallbacks = [];\n    this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[4];\n    this._autoFinishAllowed = !delayAutoFinishUntilSignal;\n    if (_onScope) {\n      // We set the transaction here on the scope so error events pick up the trace\n      // context and attach it to the error.\n      DEBUG_BUILD && logger.log(`Setting idle transaction on scope. Span ID: ${this.spanContext().spanId}`);\n      // eslint-disable-next-line deprecation/deprecation\n      _idleHub.getScope().setSpan(this);\n    }\n    if (!delayAutoFinishUntilSignal) {\n      this._restartIdleTimeout();\n    }\n    setTimeout(() => {\n      if (!this._finished) {\n        this.setStatus('deadline_exceeded');\n        this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[3];\n        this.end();\n      }\n    }, this._finalTimeout);\n  }\n\n  /** {@inheritDoc} */\n  end(endTimestamp) {\n    const endTimestampInS = spanTimeInputToSeconds(endTimestamp);\n    this._finished = true;\n    this.activities = {};\n\n    // eslint-disable-next-line deprecation/deprecation\n    if (this.op === 'ui.action.click') {\n      this.setAttribute(FINISH_REASON_TAG, this._finishReason);\n    }\n\n    // eslint-disable-next-line deprecation/deprecation\n    if (this.spanRecorder) {\n      DEBUG_BUILD &&\n      // eslint-disable-next-line deprecation/deprecation\n      logger.log('[Tracing] finishing IdleTransaction', new Date(endTimestampInS * 1000).toISOString(), this.op);\n      for (const callback of this._beforeFinishCallbacks) {\n        callback(this, endTimestampInS);\n      }\n\n      // eslint-disable-next-line deprecation/deprecation\n      this.spanRecorder.spans = this.spanRecorder.spans.filter(span => {\n        // If we are dealing with the transaction itself, we just return it\n        if (span.spanContext().spanId === this.spanContext().spanId) {\n          return true;\n        }\n\n        // We cancel all pending spans with status \"cancelled\" to indicate the idle transaction was finished early\n        if (!spanToJSON(span).timestamp) {\n          span.setStatus('cancelled');\n          span.end(endTimestampInS);\n          DEBUG_BUILD && logger.log('[Tracing] cancelling span since transaction ended early', JSON.stringify(span, undefined, 2));\n        }\n        const {\n          start_timestamp: startTime,\n          timestamp: endTime\n        } = spanToJSON(span);\n        const spanStartedBeforeTransactionFinish = startTime && startTime < endTimestampInS;\n\n        // Add a delta with idle timeout so that we prevent false positives\n        const timeoutWithMarginOfError = (this._finalTimeout + this._idleTimeout) / 1000;\n        const spanEndedBeforeFinalTimeout = endTime && startTime && endTime - startTime < timeoutWithMarginOfError;\n        if (DEBUG_BUILD) {\n          const stringifiedSpan = JSON.stringify(span, undefined, 2);\n          if (!spanStartedBeforeTransactionFinish) {\n            logger.log('[Tracing] discarding Span since it happened after Transaction was finished', stringifiedSpan);\n          } else if (!spanEndedBeforeFinalTimeout) {\n            logger.log('[Tracing] discarding Span since it finished after Transaction final timeout', stringifiedSpan);\n          }\n        }\n        return spanStartedBeforeTransactionFinish && spanEndedBeforeFinalTimeout;\n      });\n      DEBUG_BUILD && logger.log('[Tracing] flushing IdleTransaction');\n    } else {\n      DEBUG_BUILD && logger.log('[Tracing] No active IdleTransaction');\n    }\n\n    // if `this._onScope` is `true`, the transaction put itself on the scope when it started\n    if (this._onScope) {\n      // eslint-disable-next-line deprecation/deprecation\n      const scope = this._idleHub.getScope();\n      // eslint-disable-next-line deprecation/deprecation\n      if (scope.getTransaction() === this) {\n        // eslint-disable-next-line deprecation/deprecation\n        scope.setSpan(undefined);\n      }\n    }\n    return super.end(endTimestamp);\n  }\n\n  /**\n   * Register a callback function that gets executed before the transaction finishes.\n   * Useful for cleanup or if you want to add any additional spans based on current context.\n   *\n   * This is exposed because users have no other way of running something before an idle transaction\n   * finishes.\n   */\n  registerBeforeFinishCallback(callback) {\n    this._beforeFinishCallbacks.push(callback);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  initSpanRecorder(maxlen) {\n    // eslint-disable-next-line deprecation/deprecation\n    if (!this.spanRecorder) {\n      const pushActivity = id => {\n        if (this._finished) {\n          return;\n        }\n        this._pushActivity(id);\n      };\n      const popActivity = id => {\n        if (this._finished) {\n          return;\n        }\n        this._popActivity(id);\n      };\n\n      // eslint-disable-next-line deprecation/deprecation\n      this.spanRecorder = new IdleTransactionSpanRecorder(pushActivity, popActivity, this.spanContext().spanId, maxlen);\n\n      // Start heartbeat so that transactions do not run forever.\n      DEBUG_BUILD && logger.log('Starting heartbeat');\n      this._pingHeartbeat();\n    }\n    // eslint-disable-next-line deprecation/deprecation\n    this.spanRecorder.add(this);\n  }\n\n  /**\n   * Cancels the existing idle timeout, if there is one.\n   * @param restartOnChildSpanChange Default is `true`.\n   *                                 If set to false the transaction will end\n   *                                 with the last child span.\n   */\n  cancelIdleTimeout(endTimestamp) {\n    let {\n      restartOnChildSpanChange\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      restartOnChildSpanChange: true\n    };\n    this._idleTimeoutCanceledPermanently = restartOnChildSpanChange === false;\n    if (this._idleTimeoutID) {\n      clearTimeout(this._idleTimeoutID);\n      this._idleTimeoutID = undefined;\n      if (Object.keys(this.activities).length === 0 && this._idleTimeoutCanceledPermanently) {\n        this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[5];\n        this.end(endTimestamp);\n      }\n    }\n  }\n\n  /**\n   * Temporary method used to externally set the transaction's `finishReason`\n   *\n   * ** WARNING**\n   * This is for the purpose of experimentation only and will be removed in the near future, do not use!\n   *\n   * @internal\n   *\n   */\n  setFinishReason(reason) {\n    this._finishReason = reason;\n  }\n\n  /**\n   * Permits the IdleTransaction to automatically end itself via the idle timeout and heartbeat mechanisms when the `delayAutoFinishUntilSignal` option was set to `true`.\n   */\n  sendAutoFinishSignal() {\n    if (!this._autoFinishAllowed) {\n      DEBUG_BUILD && logger.log('[Tracing] Received finish signal for idle transaction.');\n      this._restartIdleTimeout();\n      this._autoFinishAllowed = true;\n    }\n  }\n\n  /**\n   * Restarts idle timeout, if there is no running idle timeout it will start one.\n   */\n  _restartIdleTimeout(endTimestamp) {\n    this.cancelIdleTimeout();\n    this._idleTimeoutID = setTimeout(() => {\n      if (!this._finished && Object.keys(this.activities).length === 0) {\n        this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[1];\n        this.end(endTimestamp);\n      }\n    }, this._idleTimeout);\n  }\n\n  /**\n   * Start tracking a specific activity.\n   * @param spanId The span id that represents the activity\n   */\n  _pushActivity(spanId) {\n    this.cancelIdleTimeout(undefined, {\n      restartOnChildSpanChange: !this._idleTimeoutCanceledPermanently\n    });\n    DEBUG_BUILD && logger.log(`[Tracing] pushActivity: ${spanId}`);\n    this.activities[spanId] = true;\n    DEBUG_BUILD && logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n  }\n\n  /**\n   * Remove an activity from usage\n   * @param spanId The span id that represents the activity\n   */\n  _popActivity(spanId) {\n    if (this.activities[spanId]) {\n      DEBUG_BUILD && logger.log(`[Tracing] popActivity ${spanId}`);\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete this.activities[spanId];\n      DEBUG_BUILD && logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n    }\n    if (Object.keys(this.activities).length === 0) {\n      const endTimestamp = timestampInSeconds();\n      if (this._idleTimeoutCanceledPermanently) {\n        if (this._autoFinishAllowed) {\n          this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[5];\n          this.end(endTimestamp);\n        }\n      } else {\n        // We need to add the timeout here to have the real endtimestamp of the transaction\n        // Remember timestampInSeconds is in seconds, timeout is in ms\n        this._restartIdleTimeout(endTimestamp + this._idleTimeout / 1000);\n      }\n    }\n  }\n\n  /**\n   * Checks when entries of this.activities are not changing for 3 beats.\n   * If this occurs we finish the transaction.\n   */\n  _beat() {\n    // We should not be running heartbeat if the idle transaction is finished.\n    if (this._finished) {\n      return;\n    }\n    const heartbeatString = Object.keys(this.activities).join('');\n    if (heartbeatString === this._prevHeartbeatString) {\n      this._heartbeatCounter++;\n    } else {\n      this._heartbeatCounter = 1;\n    }\n    this._prevHeartbeatString = heartbeatString;\n    if (this._heartbeatCounter >= 3) {\n      if (this._autoFinishAllowed) {\n        DEBUG_BUILD && logger.log('[Tracing] Transaction finished because of no change for 3 heart beats');\n        this.setStatus('deadline_exceeded');\n        this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[0];\n        this.end();\n      }\n    } else {\n      this._pingHeartbeat();\n    }\n  }\n\n  /**\n   * Pings the heartbeat\n   */\n  _pingHeartbeat() {\n    DEBUG_BUILD && logger.log(`pinging Heartbeat -> current counter: ${this._heartbeatCounter}`);\n    setTimeout(() => {\n      this._beat();\n    }, this._heartbeatInterval);\n  }\n}\nexport { IdleTransaction, IdleTransactionSpanRecorder, TRACING_DEFAULTS };","map":{"version":3,"names":["TRACING_DEFAULTS","idleTimeout","finalTimeout","heartbeatInterval","FINISH_REASON_TAG","IDLE_TRANSACTION_FINISH_REASONS","IdleTransactionSpanRecorder","SpanRecorder","constructor","_pushActivity","_popActivity","transactionSpanId","maxlen","add","span","_this","spanContext","spanId","originalEnd","end","_len","arguments","length","rest","Array","_key","apply","spanToJSON","timestamp","undefined","IdleTransaction","Transaction","transactionContext","_idleHub","_idleTimeout","_finalTimeout","_heartbeatInterval","_onScope","delayAutoFinishUntilSignal","activities","_heartbeatCounter","_finished","_idleTimeoutCanceledPermanently","_beforeFinishCallbacks","_finishReason","_autoFinishAllowed","DEBUG_BUILD","logger","log","getScope","setSpan","_restartIdleTimeout","setTimeout","setStatus","endTimestamp","endTimestampInS","spanTimeInputToSeconds","op","setAttribute","spanRecorder","Date","toISOString","callback","spans","filter","JSON","stringify","start_timestamp","startTime","endTime","spanStartedBeforeTransactionFinish","timeoutWithMarginOfError","spanEndedBeforeFinalTimeout","stringifiedSpan","scope","getTransaction","registerBeforeFinishCallback","push","initSpanRecorder","pushActivity","id","popActivity","_pingHeartbeat","cancelIdleTimeout","restartOnChildSpanChange","_idleTimeoutID","clearTimeout","Object","keys","setFinishReason","reason","sendAutoFinishSignal","timestampInSeconds","_beat","heartbeatString","join","_prevHeartbeatString"],"sources":["/Users/jeffreydebolt/Documents/fifo/cogs-dashboard/node_modules/@sentry/src/tracing/idletransaction.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport type { SpanTimeInput, TransactionContext } from '@sentry/types';\nimport { logger, timestampInSeconds } from '@sentry/utils';\n\nimport { DEBUG_BUILD } from '../debug-build';\nimport type { Hub } from '../hub';\nimport { spanTimeInputToSeconds, spanToJSON } from '../utils/spanUtils';\nimport type { Span } from './span';\nimport { SpanRecorder } from './span';\nimport { Transaction } from './transaction';\n\nexport const TRACING_DEFAULTS = {\n  idleTimeout: 1000,\n  finalTimeout: 30000,\n  heartbeatInterval: 5000,\n};\n\nconst FINISH_REASON_TAG = 'finishReason';\n\nconst IDLE_TRANSACTION_FINISH_REASONS = [\n  'heartbeatFailed',\n  'idleTimeout',\n  'documentHidden',\n  'finalTimeout',\n  'externalFinish',\n  'cancelled',\n];\n\n/**\n * @inheritDoc\n */\nexport class IdleTransactionSpanRecorder extends SpanRecorder {\n  public constructor(\n    private readonly _pushActivity: (id: string) => void,\n    private readonly _popActivity: (id: string) => void,\n    public transactionSpanId: string,\n    maxlen?: number,\n  ) {\n    super(maxlen);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public add(span: Span): void {\n    // We should make sure we do not push and pop activities for\n    // the transaction that this span recorder belongs to.\n    if (span.spanContext().spanId !== this.transactionSpanId) {\n      // We patch span.end() to pop an activity after setting an endTimestamp.\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      const originalEnd = span.end;\n      span.end = (...rest: unknown[]) => {\n        this._popActivity(span.spanContext().spanId);\n        return originalEnd.apply(span, rest);\n      };\n\n      // We should only push new activities if the span does not have an end timestamp.\n      if (spanToJSON(span).timestamp === undefined) {\n        this._pushActivity(span.spanContext().spanId);\n      }\n    }\n\n    super.add(span);\n  }\n}\n\nexport type BeforeFinishCallback = (transactionSpan: IdleTransaction, endTimestamp: number) => void;\n\n/**\n * An IdleTransaction is a transaction that automatically finishes. It does this by tracking child spans as activities.\n * You can have multiple IdleTransactions active, but if the `onScope` option is specified, the idle transaction will\n * put itself on the scope on creation.\n */\nexport class IdleTransaction extends Transaction {\n  // Activities store a list of active spans\n  public activities: Record<string, boolean>;\n  // Track state of activities in previous heartbeat\n  private _prevHeartbeatString: string | undefined;\n\n  // Amount of times heartbeat has counted. Will cause transaction to finish after 3 beats.\n  private _heartbeatCounter: number;\n\n  // We should not use heartbeat if we finished a transaction\n  private _finished: boolean;\n\n  // Idle timeout was canceled and we should finish the transaction with the last span end.\n  private _idleTimeoutCanceledPermanently: boolean;\n\n  private readonly _beforeFinishCallbacks: BeforeFinishCallback[];\n\n  /**\n   * Timer that tracks Transaction idleTimeout\n   */\n  private _idleTimeoutID: ReturnType<typeof setTimeout> | undefined;\n\n  private _finishReason: (typeof IDLE_TRANSACTION_FINISH_REASONS)[number];\n\n  private _autoFinishAllowed: boolean;\n\n  /**\n   * @deprecated Transactions will be removed in v8. Use spans instead.\n   */\n  public constructor(\n    transactionContext: TransactionContext,\n    // eslint-disable-next-line deprecation/deprecation\n    private readonly _idleHub: Hub,\n    /**\n     * The time to wait in ms until the idle transaction will be finished. This timer is started each time\n     * there are no active spans on this transaction.\n     */\n    private readonly _idleTimeout: number = TRACING_DEFAULTS.idleTimeout,\n    /**\n     * The final value in ms that a transaction cannot exceed\n     */\n    private readonly _finalTimeout: number = TRACING_DEFAULTS.finalTimeout,\n    private readonly _heartbeatInterval: number = TRACING_DEFAULTS.heartbeatInterval,\n    // Whether or not the transaction should put itself on the scope when it starts and pop itself off when it ends\n    private readonly _onScope: boolean = false,\n    /**\n     * When set to `true`, will disable the idle timeout (`_idleTimeout` option) and heartbeat mechanisms (`_heartbeatInterval`\n     * option) until the `sendAutoFinishSignal()` method is called. The final timeout mechanism (`_finalTimeout` option)\n     * will not be affected by this option, meaning the transaction will definitely be finished when the final timeout is\n     * reached, no matter what this option is configured to.\n     *\n     * Defaults to `false`.\n     */\n    delayAutoFinishUntilSignal: boolean = false,\n  ) {\n    super(transactionContext, _idleHub);\n\n    this.activities = {};\n    this._heartbeatCounter = 0;\n    this._finished = false;\n    this._idleTimeoutCanceledPermanently = false;\n    this._beforeFinishCallbacks = [];\n    this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[4];\n    this._autoFinishAllowed = !delayAutoFinishUntilSignal;\n\n    if (_onScope) {\n      // We set the transaction here on the scope so error events pick up the trace\n      // context and attach it to the error.\n      DEBUG_BUILD && logger.log(`Setting idle transaction on scope. Span ID: ${this.spanContext().spanId}`);\n      // eslint-disable-next-line deprecation/deprecation\n      _idleHub.getScope().setSpan(this);\n    }\n\n    if (!delayAutoFinishUntilSignal) {\n      this._restartIdleTimeout();\n    }\n\n    setTimeout(() => {\n      if (!this._finished) {\n        this.setStatus('deadline_exceeded');\n        this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[3];\n        this.end();\n      }\n    }, this._finalTimeout);\n  }\n\n  /** {@inheritDoc} */\n  public end(endTimestamp?: SpanTimeInput): string | undefined {\n    const endTimestampInS = spanTimeInputToSeconds(endTimestamp);\n\n    this._finished = true;\n    this.activities = {};\n\n    // eslint-disable-next-line deprecation/deprecation\n    if (this.op === 'ui.action.click') {\n      this.setAttribute(FINISH_REASON_TAG, this._finishReason);\n    }\n\n    // eslint-disable-next-line deprecation/deprecation\n    if (this.spanRecorder) {\n      DEBUG_BUILD &&\n        // eslint-disable-next-line deprecation/deprecation\n        logger.log('[Tracing] finishing IdleTransaction', new Date(endTimestampInS * 1000).toISOString(), this.op);\n\n      for (const callback of this._beforeFinishCallbacks) {\n        callback(this, endTimestampInS);\n      }\n\n      // eslint-disable-next-line deprecation/deprecation\n      this.spanRecorder.spans = this.spanRecorder.spans.filter((span: Span) => {\n        // If we are dealing with the transaction itself, we just return it\n        if (span.spanContext().spanId === this.spanContext().spanId) {\n          return true;\n        }\n\n        // We cancel all pending spans with status \"cancelled\" to indicate the idle transaction was finished early\n        if (!spanToJSON(span).timestamp) {\n          span.setStatus('cancelled');\n          span.end(endTimestampInS);\n          DEBUG_BUILD &&\n            logger.log('[Tracing] cancelling span since transaction ended early', JSON.stringify(span, undefined, 2));\n        }\n\n        const { start_timestamp: startTime, timestamp: endTime } = spanToJSON(span);\n        const spanStartedBeforeTransactionFinish = startTime && startTime < endTimestampInS;\n\n        // Add a delta with idle timeout so that we prevent false positives\n        const timeoutWithMarginOfError = (this._finalTimeout + this._idleTimeout) / 1000;\n        const spanEndedBeforeFinalTimeout = endTime && startTime && endTime - startTime < timeoutWithMarginOfError;\n\n        if (DEBUG_BUILD) {\n          const stringifiedSpan = JSON.stringify(span, undefined, 2);\n          if (!spanStartedBeforeTransactionFinish) {\n            logger.log('[Tracing] discarding Span since it happened after Transaction was finished', stringifiedSpan);\n          } else if (!spanEndedBeforeFinalTimeout) {\n            logger.log('[Tracing] discarding Span since it finished after Transaction final timeout', stringifiedSpan);\n          }\n        }\n\n        return spanStartedBeforeTransactionFinish && spanEndedBeforeFinalTimeout;\n      });\n\n      DEBUG_BUILD && logger.log('[Tracing] flushing IdleTransaction');\n    } else {\n      DEBUG_BUILD && logger.log('[Tracing] No active IdleTransaction');\n    }\n\n    // if `this._onScope` is `true`, the transaction put itself on the scope when it started\n    if (this._onScope) {\n      // eslint-disable-next-line deprecation/deprecation\n      const scope = this._idleHub.getScope();\n      // eslint-disable-next-line deprecation/deprecation\n      if (scope.getTransaction() === this) {\n        // eslint-disable-next-line deprecation/deprecation\n        scope.setSpan(undefined);\n      }\n    }\n\n    return super.end(endTimestamp);\n  }\n\n  /**\n   * Register a callback function that gets executed before the transaction finishes.\n   * Useful for cleanup or if you want to add any additional spans based on current context.\n   *\n   * This is exposed because users have no other way of running something before an idle transaction\n   * finishes.\n   */\n  public registerBeforeFinishCallback(callback: BeforeFinishCallback): void {\n    this._beforeFinishCallbacks.push(callback);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public initSpanRecorder(maxlen?: number): void {\n    // eslint-disable-next-line deprecation/deprecation\n    if (!this.spanRecorder) {\n      const pushActivity = (id: string): void => {\n        if (this._finished) {\n          return;\n        }\n        this._pushActivity(id);\n      };\n      const popActivity = (id: string): void => {\n        if (this._finished) {\n          return;\n        }\n        this._popActivity(id);\n      };\n\n      // eslint-disable-next-line deprecation/deprecation\n      this.spanRecorder = new IdleTransactionSpanRecorder(pushActivity, popActivity, this.spanContext().spanId, maxlen);\n\n      // Start heartbeat so that transactions do not run forever.\n      DEBUG_BUILD && logger.log('Starting heartbeat');\n      this._pingHeartbeat();\n    }\n    // eslint-disable-next-line deprecation/deprecation\n    this.spanRecorder.add(this);\n  }\n\n  /**\n   * Cancels the existing idle timeout, if there is one.\n   * @param restartOnChildSpanChange Default is `true`.\n   *                                 If set to false the transaction will end\n   *                                 with the last child span.\n   */\n  public cancelIdleTimeout(\n    endTimestamp?: Parameters<IdleTransaction['end']>[0],\n    {\n      restartOnChildSpanChange,\n    }: {\n      restartOnChildSpanChange?: boolean;\n    } = {\n      restartOnChildSpanChange: true,\n    },\n  ): void {\n    this._idleTimeoutCanceledPermanently = restartOnChildSpanChange === false;\n    if (this._idleTimeoutID) {\n      clearTimeout(this._idleTimeoutID);\n      this._idleTimeoutID = undefined;\n\n      if (Object.keys(this.activities).length === 0 && this._idleTimeoutCanceledPermanently) {\n        this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[5];\n        this.end(endTimestamp);\n      }\n    }\n  }\n\n  /**\n   * Temporary method used to externally set the transaction's `finishReason`\n   *\n   * ** WARNING**\n   * This is for the purpose of experimentation only and will be removed in the near future, do not use!\n   *\n   * @internal\n   *\n   */\n  public setFinishReason(reason: string): void {\n    this._finishReason = reason;\n  }\n\n  /**\n   * Permits the IdleTransaction to automatically end itself via the idle timeout and heartbeat mechanisms when the `delayAutoFinishUntilSignal` option was set to `true`.\n   */\n  public sendAutoFinishSignal(): void {\n    if (!this._autoFinishAllowed) {\n      DEBUG_BUILD && logger.log('[Tracing] Received finish signal for idle transaction.');\n      this._restartIdleTimeout();\n      this._autoFinishAllowed = true;\n    }\n  }\n\n  /**\n   * Restarts idle timeout, if there is no running idle timeout it will start one.\n   */\n  private _restartIdleTimeout(endTimestamp?: Parameters<IdleTransaction['end']>[0]): void {\n    this.cancelIdleTimeout();\n    this._idleTimeoutID = setTimeout(() => {\n      if (!this._finished && Object.keys(this.activities).length === 0) {\n        this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[1];\n        this.end(endTimestamp);\n      }\n    }, this._idleTimeout);\n  }\n\n  /**\n   * Start tracking a specific activity.\n   * @param spanId The span id that represents the activity\n   */\n  private _pushActivity(spanId: string): void {\n    this.cancelIdleTimeout(undefined, { restartOnChildSpanChange: !this._idleTimeoutCanceledPermanently });\n    DEBUG_BUILD && logger.log(`[Tracing] pushActivity: ${spanId}`);\n    this.activities[spanId] = true;\n    DEBUG_BUILD && logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n  }\n\n  /**\n   * Remove an activity from usage\n   * @param spanId The span id that represents the activity\n   */\n  private _popActivity(spanId: string): void {\n    if (this.activities[spanId]) {\n      DEBUG_BUILD && logger.log(`[Tracing] popActivity ${spanId}`);\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete this.activities[spanId];\n      DEBUG_BUILD && logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n    }\n\n    if (Object.keys(this.activities).length === 0) {\n      const endTimestamp = timestampInSeconds();\n      if (this._idleTimeoutCanceledPermanently) {\n        if (this._autoFinishAllowed) {\n          this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[5];\n          this.end(endTimestamp);\n        }\n      } else {\n        // We need to add the timeout here to have the real endtimestamp of the transaction\n        // Remember timestampInSeconds is in seconds, timeout is in ms\n        this._restartIdleTimeout(endTimestamp + this._idleTimeout / 1000);\n      }\n    }\n  }\n\n  /**\n   * Checks when entries of this.activities are not changing for 3 beats.\n   * If this occurs we finish the transaction.\n   */\n  private _beat(): void {\n    // We should not be running heartbeat if the idle transaction is finished.\n    if (this._finished) {\n      return;\n    }\n\n    const heartbeatString = Object.keys(this.activities).join('');\n\n    if (heartbeatString === this._prevHeartbeatString) {\n      this._heartbeatCounter++;\n    } else {\n      this._heartbeatCounter = 1;\n    }\n\n    this._prevHeartbeatString = heartbeatString;\n\n    if (this._heartbeatCounter >= 3) {\n      if (this._autoFinishAllowed) {\n        DEBUG_BUILD && logger.log('[Tracing] Transaction finished because of no change for 3 heart beats');\n        this.setStatus('deadline_exceeded');\n        this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[0];\n        this.end();\n      }\n    } else {\n      this._pingHeartbeat();\n    }\n  }\n\n  /**\n   * Pings the heartbeat\n   */\n  private _pingHeartbeat(): void {\n    DEBUG_BUILD && logger.log(`pinging Heartbeat -> current counter: ${this._heartbeatCounter}`);\n    setTimeout(() => {\n      this._beat();\n    }, this._heartbeatInterval);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}