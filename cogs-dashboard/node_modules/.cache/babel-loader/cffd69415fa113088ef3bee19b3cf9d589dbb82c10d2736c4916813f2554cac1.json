{"ast":null,"code":"import { logger, getFunctionName } from '@sentry/utils';\nimport { DEBUG_BUILD } from '../common/debug-build.js';\nimport { onCLS } from './web-vitals/getCLS.js';\nimport { onFID } from './web-vitals/getFID.js';\nimport { onINP } from './web-vitals/getINP.js';\nimport { onLCP } from './web-vitals/getLCP.js';\nimport { observe } from './web-vitals/lib/observe.js';\nimport { onTTFB } from './web-vitals/onTTFB.js';\nconst handlers = {};\nconst instrumented = {};\nlet _previousCls;\nlet _previousFid;\nlet _previousLcp;\nlet _previousTtfb;\nlet _previousInp;\n\n/**\n * Add a callback that will be triggered when a CLS metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n *\n * Pass `stopOnCallback = true` to stop listening for CLS when the cleanup callback is called.\n * This will lead to the CLS being finalized and frozen.\n */\nfunction addClsInstrumentationHandler(callback) {\n  let stopOnCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return addMetricObserver('cls', callback, instrumentCls, _previousCls, stopOnCallback);\n}\n\n/**\n * Add a callback that will be triggered when a LCP metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n *\n * Pass `stopOnCallback = true` to stop listening for LCP when the cleanup callback is called.\n * This will lead to the LCP being finalized and frozen.\n */\nfunction addLcpInstrumentationHandler(callback) {\n  let stopOnCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return addMetricObserver('lcp', callback, instrumentLcp, _previousLcp, stopOnCallback);\n}\n\n/**\n * Add a callback that will be triggered when a FID metric is available.\n */\nfunction addTtfbInstrumentationHandler(callback) {\n  return addMetricObserver('ttfb', callback, instrumentTtfb, _previousTtfb);\n}\n\n/**\n * Add a callback that will be triggered when a FID metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n */\nfunction addFidInstrumentationHandler(callback) {\n  return addMetricObserver('fid', callback, instrumentFid, _previousFid);\n}\n\n/**\n * Add a callback that will be triggered when a INP metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n */\nfunction addInpInstrumentationHandler(callback) {\n  return addMetricObserver('inp', callback, instrumentInp, _previousInp);\n}\n\n/**\n * Add a callback that will be triggered when a performance observer is triggered,\n * and receives the entries of the observer.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n */\nfunction addPerformanceInstrumentationHandler(type, callback) {\n  addHandler(type, callback);\n  if (!instrumented[type]) {\n    instrumentPerformanceObserver(type);\n    instrumented[type] = true;\n  }\n  return getCleanupCallback(type, callback);\n}\n\n/** Trigger all handlers of a given type. */\nfunction triggerHandlers(type, data) {\n  const typeHandlers = handlers[type];\n  if (!typeHandlers || !typeHandlers.length) {\n    return;\n  }\n  for (const handler of typeHandlers) {\n    try {\n      handler(data);\n    } catch (e) {\n      DEBUG_BUILD && logger.error(`Error while triggering instrumentation handler.\\nType: ${type}\\nName: ${getFunctionName(handler)}\\nError:`, e);\n    }\n  }\n}\nfunction instrumentCls() {\n  return onCLS(metric => {\n    triggerHandlers('cls', {\n      metric\n    });\n    _previousCls = metric;\n  }, {\n    reportAllChanges: true\n  });\n}\nfunction instrumentFid() {\n  return onFID(metric => {\n    triggerHandlers('fid', {\n      metric\n    });\n    _previousFid = metric;\n  });\n}\nfunction instrumentLcp() {\n  return onLCP(metric => {\n    triggerHandlers('lcp', {\n      metric\n    });\n    _previousLcp = metric;\n  });\n}\nfunction instrumentTtfb() {\n  return onTTFB(metric => {\n    triggerHandlers('ttfb', {\n      metric\n    });\n    _previousTtfb = metric;\n  });\n}\nfunction instrumentInp() {\n  return onINP(metric => {\n    triggerHandlers('inp', {\n      metric\n    });\n    _previousInp = metric;\n  });\n}\nfunction addMetricObserver(type, callback, instrumentFn, previousValue) {\n  let stopOnCallback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  addHandler(type, callback);\n  let stopListening;\n  if (!instrumented[type]) {\n    stopListening = instrumentFn();\n    instrumented[type] = true;\n  }\n  if (previousValue) {\n    callback({\n      metric: previousValue\n    });\n  }\n  return getCleanupCallback(type, callback, stopOnCallback ? stopListening : undefined);\n}\nfunction instrumentPerformanceObserver(type) {\n  const options = {};\n\n  // Special per-type options we want to use\n  if (type === 'event') {\n    options.durationThreshold = 0;\n  }\n  observe(type, entries => {\n    triggerHandlers(type, {\n      entries\n    });\n  }, options);\n}\nfunction addHandler(type, handler) {\n  handlers[type] = handlers[type] || [];\n  handlers[type].push(handler);\n}\n\n// Get a callback which can be called to remove the instrumentation handler\nfunction getCleanupCallback(type, callback, stopListening) {\n  return () => {\n    if (stopListening) {\n      stopListening();\n    }\n    const typeHandlers = handlers[type];\n    if (!typeHandlers) {\n      return;\n    }\n    const index = typeHandlers.indexOf(callback);\n    if (index !== -1) {\n      typeHandlers.splice(index, 1);\n    }\n  };\n}\nexport { addClsInstrumentationHandler, addFidInstrumentationHandler, addInpInstrumentationHandler, addLcpInstrumentationHandler, addPerformanceInstrumentationHandler, addTtfbInstrumentationHandler };","map":{"version":3,"names":["handlers","instrumented","_previousCls","_previousFid","_previousLcp","_previousTtfb","_previousInp","addClsInstrumentationHandler","callback","stopOnCallback","arguments","length","undefined","addMetricObserver","instrumentCls","addLcpInstrumentationHandler","instrumentLcp","addTtfbInstrumentationHandler","instrumentTtfb","addFidInstrumentationHandler","instrumentFid","addInpInstrumentationHandler","instrumentInp","addPerformanceInstrumentationHandler","type","addHandler","instrumentPerformanceObserver","getCleanupCallback","triggerHandlers","data","typeHandlers","handler","e","DEBUG_BUILD","logger","error","getFunctionName","onCLS","metric","reportAllChanges","onFID","onLCP","onTTFB","onINP","instrumentFn","previousValue","stopListening","options","durationThreshold","observe","entries","push","index","indexOf","splice"],"sources":["/Users/jeffreydebolt/Documents/fifo/cogs-dashboard/node_modules/@sentry-internal/src/browser/instrument.ts"],"sourcesContent":["import { getFunctionName, logger } from '@sentry/utils';\n\nimport { DEBUG_BUILD } from '../common/debug-build';\nimport { onCLS } from './web-vitals/getCLS';\nimport { onFID } from './web-vitals/getFID';\nimport { onINP } from './web-vitals/getINP';\nimport { onLCP } from './web-vitals/getLCP';\nimport { observe } from './web-vitals/lib/observe';\nimport { onTTFB } from './web-vitals/onTTFB';\n\ntype InstrumentHandlerTypePerformanceObserver =\n  | 'longtask'\n  | 'event'\n  | 'navigation'\n  | 'paint'\n  | 'resource'\n  | 'first-input';\n\ntype InstrumentHandlerTypeMetric = 'cls' | 'lcp' | 'fid' | 'ttfb' | 'inp';\n\n// We provide this here manually instead of relying on a global, as this is not available in non-browser environements\n// And we do not want to expose such types\ninterface PerformanceEntry {\n  readonly duration: number;\n  readonly entryType: string;\n  readonly name: string;\n  readonly startTime: number;\n  toJSON(): Record<string, unknown>;\n}\ninterface PerformanceEventTiming extends PerformanceEntry {\n  processingStart: number;\n  processingEnd: number;\n  duration: number;\n  cancelable?: boolean;\n  target?: unknown | null;\n  interactionId?: number;\n}\n\ninterface Metric {\n  /**\n   * The name of the metric (in acronym form).\n   */\n  name: 'CLS' | 'FCP' | 'FID' | 'INP' | 'LCP' | 'TTFB';\n\n  /**\n   * The current value of the metric.\n   */\n  value: number;\n\n  /**\n   * The rating as to whether the metric value is within the \"good\",\n   * \"needs improvement\", or \"poor\" thresholds of the metric.\n   */\n  rating: 'good' | 'needs-improvement' | 'poor';\n\n  /**\n   * The delta between the current value and the last-reported value.\n   * On the first report, `delta` and `value` will always be the same.\n   */\n  delta: number;\n\n  /**\n   * A unique ID representing this particular metric instance. This ID can\n   * be used by an analytics tool to dedupe multiple values sent for the same\n   * metric instance, or to group multiple deltas together and calculate a\n   * total. It can also be used to differentiate multiple different metric\n   * instances sent from the same page, which can happen if the page is\n   * restored from the back/forward cache (in that case new metrics object\n   * get created).\n   */\n  id: string;\n\n  /**\n   * Any performance entries relevant to the metric value calculation.\n   * The array may also be empty if the metric value was not based on any\n   * entries (e.g. a CLS value of 0 given no layout shifts).\n   */\n  entries: PerformanceEntry[];\n\n  /**\n   * The type of navigation\n   *\n   * Navigation Timing API (or `undefined` if the browser doesn't\n   * support that API). For pages that are restored from the bfcache, this\n   * value will be 'back-forward-cache'.\n   */\n  navigationType: 'navigate' | 'reload' | 'back-forward' | 'back-forward-cache' | 'prerender';\n}\n\ntype InstrumentHandlerType = InstrumentHandlerTypeMetric | InstrumentHandlerTypePerformanceObserver;\n\ntype StopListening = undefined | void | (() => void);\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype InstrumentHandlerCallback = (data: any) => void;\n\ntype CleanupHandlerCallback = () => void;\n\nconst handlers: { [key in InstrumentHandlerType]?: InstrumentHandlerCallback[] } = {};\nconst instrumented: { [key in InstrumentHandlerType]?: boolean } = {};\n\nlet _previousCls: Metric | undefined;\nlet _previousFid: Metric | undefined;\nlet _previousLcp: Metric | undefined;\nlet _previousTtfb: Metric | undefined;\nlet _previousInp: Metric | undefined;\n\n/**\n * Add a callback that will be triggered when a CLS metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n *\n * Pass `stopOnCallback = true` to stop listening for CLS when the cleanup callback is called.\n * This will lead to the CLS being finalized and frozen.\n */\nexport function addClsInstrumentationHandler(\n  callback: (data: { metric: Metric }) => void,\n  stopOnCallback = false,\n): CleanupHandlerCallback {\n  return addMetricObserver('cls', callback, instrumentCls, _previousCls, stopOnCallback);\n}\n\n/**\n * Add a callback that will be triggered when a LCP metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n *\n * Pass `stopOnCallback = true` to stop listening for LCP when the cleanup callback is called.\n * This will lead to the LCP being finalized and frozen.\n */\nexport function addLcpInstrumentationHandler(\n  callback: (data: { metric: Metric }) => void,\n  stopOnCallback = false,\n): CleanupHandlerCallback {\n  return addMetricObserver('lcp', callback, instrumentLcp, _previousLcp, stopOnCallback);\n}\n\n/**\n * Add a callback that will be triggered when a FID metric is available.\n */\nexport function addTtfbInstrumentationHandler(callback: (data: { metric: Metric }) => void): CleanupHandlerCallback {\n  return addMetricObserver('ttfb', callback, instrumentTtfb, _previousTtfb);\n}\n\n/**\n * Add a callback that will be triggered when a FID metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n */\nexport function addFidInstrumentationHandler(callback: (data: { metric: Metric }) => void): CleanupHandlerCallback {\n  return addMetricObserver('fid', callback, instrumentFid, _previousFid);\n}\n\n/**\n * Add a callback that will be triggered when a INP metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n */\nexport function addInpInstrumentationHandler(\n  callback: (data: { metric: Omit<Metric, 'entries'> & { entries: PerformanceEventTiming[] } }) => void,\n): CleanupHandlerCallback {\n  return addMetricObserver('inp', callback, instrumentInp, _previousInp);\n}\n\nexport function addPerformanceInstrumentationHandler(\n  type: 'event' | 'first-input',\n  callback: (data: { entries: ((PerformanceEntry & { target?: unknown | null }) | PerformanceEventTiming)[] }) => void,\n): CleanupHandlerCallback;\nexport function addPerformanceInstrumentationHandler(\n  type: InstrumentHandlerTypePerformanceObserver,\n  callback: (data: { entries: PerformanceEntry[] }) => void,\n): CleanupHandlerCallback;\n\n/**\n * Add a callback that will be triggered when a performance observer is triggered,\n * and receives the entries of the observer.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n */\nexport function addPerformanceInstrumentationHandler(\n  type: InstrumentHandlerTypePerformanceObserver,\n  callback: (data: { entries: PerformanceEntry[] }) => void,\n): CleanupHandlerCallback {\n  addHandler(type, callback);\n\n  if (!instrumented[type]) {\n    instrumentPerformanceObserver(type);\n    instrumented[type] = true;\n  }\n\n  return getCleanupCallback(type, callback);\n}\n\n/** Trigger all handlers of a given type. */\nfunction triggerHandlers(type: InstrumentHandlerType, data: unknown): void {\n  const typeHandlers = handlers[type];\n\n  if (!typeHandlers || !typeHandlers.length) {\n    return;\n  }\n\n  for (const handler of typeHandlers) {\n    try {\n      handler(data);\n    } catch (e) {\n      DEBUG_BUILD &&\n        logger.error(\n          `Error while triggering instrumentation handler.\\nType: ${type}\\nName: ${getFunctionName(handler)}\\nError:`,\n          e,\n        );\n    }\n  }\n}\n\nfunction instrumentCls(): StopListening {\n  return onCLS(\n    metric => {\n      triggerHandlers('cls', {\n        metric,\n      });\n      _previousCls = metric;\n    },\n    { reportAllChanges: true },\n  );\n}\n\nfunction instrumentFid(): void {\n  return onFID(metric => {\n    triggerHandlers('fid', {\n      metric,\n    });\n    _previousFid = metric;\n  });\n}\n\nfunction instrumentLcp(): StopListening {\n  return onLCP(metric => {\n    triggerHandlers('lcp', {\n      metric,\n    });\n    _previousLcp = metric;\n  });\n}\n\nfunction instrumentTtfb(): StopListening {\n  return onTTFB(metric => {\n    triggerHandlers('ttfb', {\n      metric,\n    });\n    _previousTtfb = metric;\n  });\n}\n\nfunction instrumentInp(): void {\n  return onINP(metric => {\n    triggerHandlers('inp', {\n      metric,\n    });\n    _previousInp = metric;\n  });\n}\n\nfunction addMetricObserver(\n  type: InstrumentHandlerTypeMetric,\n  callback: InstrumentHandlerCallback,\n  instrumentFn: () => StopListening,\n  previousValue: Metric | undefined,\n  stopOnCallback = false,\n): CleanupHandlerCallback {\n  addHandler(type, callback);\n\n  let stopListening: StopListening | undefined;\n\n  if (!instrumented[type]) {\n    stopListening = instrumentFn();\n    instrumented[type] = true;\n  }\n\n  if (previousValue) {\n    callback({ metric: previousValue });\n  }\n\n  return getCleanupCallback(type, callback, stopOnCallback ? stopListening : undefined);\n}\n\nfunction instrumentPerformanceObserver(type: InstrumentHandlerTypePerformanceObserver): void {\n  const options: PerformanceObserverInit = {};\n\n  // Special per-type options we want to use\n  if (type === 'event') {\n    options.durationThreshold = 0;\n  }\n\n  observe(\n    type,\n    entries => {\n      triggerHandlers(type, { entries });\n    },\n    options,\n  );\n}\n\nfunction addHandler(type: InstrumentHandlerType, handler: InstrumentHandlerCallback): void {\n  handlers[type] = handlers[type] || [];\n  (handlers[type] as InstrumentHandlerCallback[]).push(handler);\n}\n\n// Get a callback which can be called to remove the instrumentation handler\nfunction getCleanupCallback(\n  type: InstrumentHandlerType,\n  callback: InstrumentHandlerCallback,\n  stopListening: StopListening,\n): CleanupHandlerCallback {\n  return () => {\n    if (stopListening) {\n      stopListening();\n    }\n\n    const typeHandlers = handlers[type];\n\n    if (!typeHandlers) {\n      return;\n    }\n\n    const index = typeHandlers.indexOf(callback);\n    if (index !== -1) {\n      typeHandlers.splice(index, 1);\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}