{"ast":null,"code":"import { makeDsn, logger, checkOrSetAlreadyCaught, isParameterizedString, isPrimitive, resolvedSyncPromise, addItemToEnvelope, createAttachmentEnvelopeItem, SyncPromise, rejectedSyncPromise, SentryError, isThenable, isPlainObject } from '@sentry/utils';\nimport { getEnvelopeEndpointWithUrlEncodedAuth } from './api.js';\nimport { DEBUG_BUILD } from './debug-build.js';\nimport { createEventEnvelope, createSessionEnvelope } from './envelope.js';\nimport { getClient } from './exports.js';\nimport { getIsolationScope } from './hub.js';\nimport { setupIntegration, afterSetupIntegrations, setupIntegrations } from './integration.js';\nimport { createMetricEnvelope } from './metrics/envelope.js';\nimport { updateSession } from './session.js';\nimport { getDynamicSamplingContextFromClient } from './tracing/dynamicSamplingContext.js';\nimport { prepareEvent } from './utils/prepareEvent.js';\nconst ALREADY_SEEN_ERROR = \"Not capturing exception because it's already been captured.\";\n\n/**\n * Base implementation for all JavaScript SDK clients.\n *\n * Call the constructor with the corresponding options\n * specific to the client subclass. To access these options later, use\n * {@link Client.getOptions}.\n *\n * If a Dsn is specified in the options, it will be parsed and stored. Use\n * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is\n * invalid, the constructor will throw a {@link SentryException}. Note that\n * without a valid Dsn, the SDK will not send any events to Sentry.\n *\n * Before sending an event, it is passed through\n * {@link BaseClient._prepareEvent} to add SDK information and scope data\n * (breadcrumbs and context). To add more custom information, override this\n * method and extend the resulting prepared event.\n *\n * To issue automatically created events (e.g. via instrumentation), use\n * {@link Client.captureEvent}. It will prepare the event and pass it through\n * the callback lifecycle. To issue auto-breadcrumbs, use\n * {@link Client.addBreadcrumb}.\n *\n * @example\n * class NodeClient extends BaseClient<NodeOptions> {\n *   public constructor(options: NodeOptions) {\n *     super(options);\n *   }\n *\n *   // ...\n * }\n */\nclass BaseClient {\n  /**\n   * A reference to a metrics aggregator\n   *\n   * @experimental Note this is alpha API. It may experience breaking changes in the future.\n   */\n\n  /** Options passed to the SDK. */\n\n  /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */\n\n  /** Array of set up integrations. */\n\n  /** Indicates whether this client's integrations have been set up. */\n\n  /** Number of calls being processed */\n\n  /** Holds flushable  */\n\n  // eslint-disable-next-line @typescript-eslint/ban-types\n\n  /**\n   * Initializes this client instance.\n   *\n   * @param options Options for the client.\n   */\n  constructor(options) {\n    this._options = options;\n    this._integrations = {};\n    this._integrationsInitialized = false;\n    this._numProcessing = 0;\n    this._outcomes = {};\n    this._hooks = {};\n    this._eventProcessors = [];\n    if (options.dsn) {\n      this._dsn = makeDsn(options.dsn);\n    } else {\n      DEBUG_BUILD && logger.warn('No DSN provided, client will not send events.');\n    }\n    if (this._dsn) {\n      const url = getEnvelopeEndpointWithUrlEncodedAuth(this._dsn, options);\n      this._transport = options.transport({\n        tunnel: this._options.tunnel,\n        recordDroppedEvent: this.recordDroppedEvent.bind(this),\n        ...options.transportOptions,\n        url\n      });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n  captureException(exception, hint, scope) {\n    // ensure we haven't captured this very object before\n    if (checkOrSetAlreadyCaught(exception)) {\n      DEBUG_BUILD && logger.log(ALREADY_SEEN_ERROR);\n      return;\n    }\n    let eventId = hint && hint.event_id;\n    this._process(this.eventFromException(exception, hint).then(event => this._captureEvent(event, hint, scope)).then(result => {\n      eventId = result;\n    }));\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  captureMessage(message,\n  // eslint-disable-next-line deprecation/deprecation\n  level, hint, scope) {\n    let eventId = hint && hint.event_id;\n    const eventMessage = isParameterizedString(message) ? message : String(message);\n    const promisedEvent = isPrimitive(message) ? this.eventFromMessage(eventMessage, level, hint) : this.eventFromException(message, hint);\n    this._process(promisedEvent.then(event => this._captureEvent(event, hint, scope)).then(result => {\n      eventId = result;\n    }));\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  captureEvent(event, hint, scope) {\n    // ensure we haven't captured this very object before\n    if (hint && hint.originalException && checkOrSetAlreadyCaught(hint.originalException)) {\n      DEBUG_BUILD && logger.log(ALREADY_SEEN_ERROR);\n      return;\n    }\n    let eventId = hint && hint.event_id;\n    const sdkProcessingMetadata = event.sdkProcessingMetadata || {};\n    const capturedSpanScope = sdkProcessingMetadata.capturedSpanScope;\n    this._process(this._captureEvent(event, hint, capturedSpanScope || scope).then(result => {\n      eventId = result;\n    }));\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  captureSession(session) {\n    if (!(typeof session.release === 'string')) {\n      DEBUG_BUILD && logger.warn('Discarded session because of missing or non-string release');\n    } else {\n      this.sendSession(session);\n      // After sending, we set init false to indicate it's not the first occurrence\n      updateSession(session, {\n        init: false\n      });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getDsn() {\n    return this._dsn;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getOptions() {\n    return this._options;\n  }\n\n  /**\n   * @see SdkMetadata in @sentry/types\n   *\n   * @return The metadata of the SDK\n   */\n  getSdkMetadata() {\n    return this._options._metadata;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getTransport() {\n    return this._transport;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  flush(timeout) {\n    const transport = this._transport;\n    if (transport) {\n      if (this.metricsAggregator) {\n        this.metricsAggregator.flush();\n      }\n      return this._isClientDoneProcessing(timeout).then(clientFinished => {\n        return transport.flush(timeout).then(transportFlushed => clientFinished && transportFlushed);\n      });\n    } else {\n      return resolvedSyncPromise(true);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  close(timeout) {\n    return this.flush(timeout).then(result => {\n      this.getOptions().enabled = false;\n      if (this.metricsAggregator) {\n        this.metricsAggregator.close();\n      }\n      return result;\n    });\n  }\n\n  /** Get all installed event processors. */\n  getEventProcessors() {\n    return this._eventProcessors;\n  }\n\n  /** @inheritDoc */\n  addEventProcessor(eventProcessor) {\n    this._eventProcessors.push(eventProcessor);\n  }\n\n  /**\n   * This is an internal function to setup all integrations that should run on the client.\n   * @deprecated Use `client.init()` instead.\n   */\n  setupIntegrations(forceInitialize) {\n    if (forceInitialize && !this._integrationsInitialized || this._isEnabled() && !this._integrationsInitialized) {\n      this._setupIntegrations();\n    }\n  }\n\n  /** @inheritdoc */\n  init() {\n    if (this._isEnabled()) {\n      this._setupIntegrations();\n    }\n  }\n\n  /**\n   * Gets an installed integration by its `id`.\n   *\n   * @returns The installed integration or `undefined` if no integration with that `id` was installed.\n   * @deprecated Use `getIntegrationByName()` instead.\n   */\n  getIntegrationById(integrationId) {\n    return this.getIntegrationByName(integrationId);\n  }\n\n  /**\n   * Gets an installed integration by its name.\n   *\n   * @returns The installed integration or `undefined` if no integration with that `name` was installed.\n   */\n  getIntegrationByName(integrationName) {\n    return this._integrations[integrationName];\n  }\n\n  /**\n   * Returns the client's instance of the given integration class, it any.\n   * @deprecated Use `getIntegrationByName()` instead.\n   */\n  getIntegration(integration) {\n    try {\n      return this._integrations[integration.id] || null;\n    } catch (_oO) {\n      DEBUG_BUILD && logger.warn(`Cannot retrieve integration ${integration.id} from the current Client`);\n      return null;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  addIntegration(integration) {\n    const isAlreadyInstalled = this._integrations[integration.name];\n\n    // This hook takes care of only installing if not already installed\n    setupIntegration(this, integration, this._integrations);\n    // Here we need to check manually to make sure to not run this multiple times\n    if (!isAlreadyInstalled) {\n      afterSetupIntegrations(this, [integration]);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  sendEvent(event) {\n    let hint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.emit('beforeSendEvent', event, hint);\n    let env = createEventEnvelope(event, this._dsn, this._options._metadata, this._options.tunnel);\n    for (const attachment of hint.attachments || []) {\n      env = addItemToEnvelope(env, createAttachmentEnvelopeItem(attachment, this._options.transportOptions && this._options.transportOptions.textEncoder));\n    }\n    const promise = this._sendEnvelope(env);\n    if (promise) {\n      promise.then(sendResponse => this.emit('afterSendEvent', event, sendResponse), null);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  sendSession(session) {\n    const env = createSessionEnvelope(session, this._dsn, this._options._metadata, this._options.tunnel);\n\n    // _sendEnvelope should not throw\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this._sendEnvelope(env);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  recordDroppedEvent(reason, category, eventOrCount) {\n    if (this._options.sendClientReports) {\n      // TODO v9: We do not need the `event` passed as third argument anymore, and can possibly remove this overload\n      // If event is passed as third argument, we assume this is a count of 1\n      const count = typeof eventOrCount === 'number' ? eventOrCount : 1;\n\n      // We want to track each category (error, transaction, session, replay_event) separately\n      // but still keep the distinction between different type of outcomes.\n      // We could use nested maps, but it's much easier to read and type this way.\n      // A correct type for map-based implementation if we want to go that route\n      // would be `Partial<Record<SentryRequestType, Partial<Record<Outcome, number>>>>`\n      // With typescript 4.1 we could even use template literal types\n      const key = `${reason}:${category}`;\n      DEBUG_BUILD && logger.log(`Recording outcome: \"${key}\"${count > 1 ? ` (${count} times)` : ''}`);\n      this._outcomes[key] = (this._outcomes[key] || 0) + count;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  captureAggregateMetrics(metricBucketItems) {\n    DEBUG_BUILD && logger.log(`Flushing aggregated metrics, number of metrics: ${metricBucketItems.length}`);\n    const metricsEnvelope = createMetricEnvelope(metricBucketItems, this._dsn, this._options._metadata, this._options.tunnel);\n\n    // _sendEnvelope should not throw\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this._sendEnvelope(metricsEnvelope);\n  }\n\n  // Keep on() & emit() signatures in sync with types' client.ts interface\n  /* eslint-disable @typescript-eslint/unified-signatures */\n\n  /** @inheritdoc */\n\n  /** @inheritdoc */\n  on(hook, callback) {\n    if (!this._hooks[hook]) {\n      this._hooks[hook] = [];\n    }\n\n    // @ts-expect-error We assue the types are correct\n    this._hooks[hook].push(callback);\n  }\n\n  /** @inheritdoc */\n\n  /** @inheritdoc */\n  emit(hook) {\n    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      rest[_key - 1] = arguments[_key];\n    }\n    if (this._hooks[hook]) {\n      this._hooks[hook].forEach(callback => callback(...rest));\n    }\n  }\n\n  /* eslint-enable @typescript-eslint/unified-signatures */\n\n  /** Setup integrations for this client. */\n  _setupIntegrations() {\n    const {\n      integrations\n    } = this._options;\n    this._integrations = setupIntegrations(this, integrations);\n    afterSetupIntegrations(this, integrations);\n\n    // TODO v8: We don't need this flag anymore\n    this._integrationsInitialized = true;\n  }\n\n  /** Updates existing session based on the provided event */\n  _updateSessionFromEvent(session, event) {\n    let crashed = false;\n    let errored = false;\n    const exceptions = event.exception && event.exception.values;\n    if (exceptions) {\n      errored = true;\n      for (const ex of exceptions) {\n        const mechanism = ex.mechanism;\n        if (mechanism && mechanism.handled === false) {\n          crashed = true;\n          break;\n        }\n      }\n    }\n\n    // A session is updated and that session update is sent in only one of the two following scenarios:\n    // 1. Session with non terminal status and 0 errors + an error occurred -> Will set error count to 1 and send update\n    // 2. Session with non terminal status and 1 error + a crash occurred -> Will set status crashed and send update\n    const sessionNonTerminal = session.status === 'ok';\n    const shouldUpdateAndSend = sessionNonTerminal && session.errors === 0 || sessionNonTerminal && crashed;\n    if (shouldUpdateAndSend) {\n      updateSession(session, {\n        ...(crashed && {\n          status: 'crashed'\n        }),\n        errors: session.errors || Number(errored || crashed)\n      });\n      this.captureSession(session);\n    }\n  }\n\n  /**\n   * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying\n   * \"no\" (resolving to `false`) in order to give the client a chance to potentially finish first.\n   *\n   * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not\n   * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to\n   * `true`.\n   * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and\n   * `false` otherwise\n   */\n  _isClientDoneProcessing(timeout) {\n    return new SyncPromise(resolve => {\n      let ticked = 0;\n      const tick = 1;\n      const interval = setInterval(() => {\n        if (this._numProcessing == 0) {\n          clearInterval(interval);\n          resolve(true);\n        } else {\n          ticked += tick;\n          if (timeout && ticked >= timeout) {\n            clearInterval(interval);\n            resolve(false);\n          }\n        }\n      }, tick);\n    });\n  }\n\n  /** Determines whether this SDK is enabled and a transport is present. */\n  _isEnabled() {\n    return this.getOptions().enabled !== false && this._transport !== undefined;\n  }\n\n  /**\n   * Adds common information to events.\n   *\n   * The information includes release and environment from `options`,\n   * breadcrumbs and context (extra, tags and user) from the scope.\n   *\n   * Information that is already present in the event is never overwritten. For\n   * nested objects, such as the context, keys are merged.\n   *\n   * @param event The original event.\n   * @param hint May contain additional information about the original exception.\n   * @param scope A scope containing event metadata.\n   * @returns A new event with more information.\n   */\n  _prepareEvent(event, hint, scope) {\n    let isolationScope = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : getIsolationScope();\n    const options = this.getOptions();\n    const integrations = Object.keys(this._integrations);\n    if (!hint.integrations && integrations.length > 0) {\n      hint.integrations = integrations;\n    }\n    this.emit('preprocessEvent', event, hint);\n    return prepareEvent(options, event, hint, scope, this, isolationScope).then(evt => {\n      if (evt === null) {\n        return evt;\n      }\n      const propagationContext = {\n        ...isolationScope.getPropagationContext(),\n        ...(scope ? scope.getPropagationContext() : undefined)\n      };\n      const trace = evt.contexts && evt.contexts.trace;\n      if (!trace && propagationContext) {\n        const {\n          traceId: trace_id,\n          spanId,\n          parentSpanId,\n          dsc\n        } = propagationContext;\n        evt.contexts = {\n          trace: {\n            trace_id,\n            span_id: spanId,\n            parent_span_id: parentSpanId\n          },\n          ...evt.contexts\n        };\n        const dynamicSamplingContext = dsc ? dsc : getDynamicSamplingContextFromClient(trace_id, this, scope);\n        evt.sdkProcessingMetadata = {\n          dynamicSamplingContext,\n          ...evt.sdkProcessingMetadata\n        };\n      }\n      return evt;\n    });\n  }\n\n  /**\n   * Processes the event and logs an error in case of rejection\n   * @param event\n   * @param hint\n   * @param scope\n   */\n  _captureEvent(event) {\n    let hint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let scope = arguments.length > 2 ? arguments[2] : undefined;\n    return this._processEvent(event, hint, scope).then(finalEvent => {\n      return finalEvent.event_id;\n    }, reason => {\n      if (DEBUG_BUILD) {\n        // If something's gone wrong, log the error as a warning. If it's just us having used a `SentryError` for\n        // control flow, log just the message (no stack) as a log-level log.\n        const sentryError = reason;\n        if (sentryError.logLevel === 'log') {\n          logger.log(sentryError.message);\n        } else {\n          logger.warn(sentryError);\n        }\n      }\n      return undefined;\n    });\n  }\n\n  /**\n   * Processes an event (either error or message) and sends it to Sentry.\n   *\n   * This also adds breadcrumbs and context information to the event. However,\n   * platform specific meta data (such as the User's IP address) must be added\n   * by the SDK implementor.\n   *\n   *\n   * @param event The event to send to Sentry.\n   * @param hint May contain additional information about the original exception.\n   * @param scope A scope containing event metadata.\n   * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.\n   */\n  _processEvent(event, hint, scope) {\n    const options = this.getOptions();\n    const {\n      sampleRate\n    } = options;\n    const isTransaction = isTransactionEvent(event);\n    const isError = isErrorEvent(event);\n    const eventType = event.type || 'error';\n    const beforeSendLabel = `before send for type \\`${eventType}\\``;\n\n    // 1.0 === 100% events are sent\n    // 0.0 === 0% events are sent\n    // Sampling for transaction happens somewhere else\n    if (isError && typeof sampleRate === 'number' && Math.random() > sampleRate) {\n      this.recordDroppedEvent('sample_rate', 'error', event);\n      return rejectedSyncPromise(new SentryError(`Discarding event because it's not included in the random sample (sampling rate = ${sampleRate})`, 'log'));\n    }\n    const dataCategory = eventType === 'replay_event' ? 'replay' : eventType;\n    const sdkProcessingMetadata = event.sdkProcessingMetadata || {};\n    const capturedSpanIsolationScope = sdkProcessingMetadata.capturedSpanIsolationScope;\n    return this._prepareEvent(event, hint, scope, capturedSpanIsolationScope).then(prepared => {\n      if (prepared === null) {\n        this.recordDroppedEvent('event_processor', dataCategory, event);\n        throw new SentryError('An event processor returned `null`, will not send event.', 'log');\n      }\n      const isInternalException = hint.data && hint.data.__sentry__ === true;\n      if (isInternalException) {\n        return prepared;\n      }\n      const result = processBeforeSend(options, prepared, hint);\n      return _validateBeforeSendResult(result, beforeSendLabel);\n    }).then(processedEvent => {\n      if (processedEvent === null) {\n        this.recordDroppedEvent('before_send', dataCategory, event);\n        if (isTransaction) {\n          const spans = event.spans || [];\n          // the transaction itself counts as one span, plus all the child spans that are added\n          const spanCount = 1 + spans.length;\n          this.recordDroppedEvent('before_send', 'span', spanCount);\n        }\n        throw new SentryError(`${beforeSendLabel} returned \\`null\\`, will not send event.`, 'log');\n      }\n      const session = scope && scope.getSession();\n      if (!isTransaction && session) {\n        this._updateSessionFromEvent(session, processedEvent);\n      }\n      if (isTransaction) {\n        const spanCountBefore = processedEvent.sdkProcessingMetadata && processedEvent.sdkProcessingMetadata.spanCountBeforeProcessing || 0;\n        const spanCountAfter = processedEvent.spans ? processedEvent.spans.length : 0;\n        const droppedSpanCount = spanCountBefore - spanCountAfter;\n        if (droppedSpanCount > 0) {\n          this.recordDroppedEvent('before_send', 'span', droppedSpanCount);\n        }\n      }\n\n      // None of the Sentry built event processor will update transaction name,\n      // so if the transaction name has been changed by an event processor, we know\n      // it has to come from custom event processor added by a user\n      const transactionInfo = processedEvent.transaction_info;\n      if (isTransaction && transactionInfo && processedEvent.transaction !== event.transaction) {\n        const source = 'custom';\n        processedEvent.transaction_info = {\n          ...transactionInfo,\n          source\n        };\n      }\n      this.sendEvent(processedEvent, hint);\n      return processedEvent;\n    }).then(null, reason => {\n      if (reason instanceof SentryError) {\n        throw reason;\n      }\n      this.captureException(reason, {\n        data: {\n          __sentry__: true\n        },\n        originalException: reason\n      });\n      throw new SentryError(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\\nReason: ${reason}`);\n    });\n  }\n\n  /**\n   * Occupies the client with processing and event\n   */\n  _process(promise) {\n    this._numProcessing++;\n    void promise.then(value => {\n      this._numProcessing--;\n      return value;\n    }, reason => {\n      this._numProcessing--;\n      return reason;\n    });\n  }\n\n  /**\n   * @inheritdoc\n   */\n  _sendEnvelope(envelope) {\n    this.emit('beforeEnvelope', envelope);\n    if (this._isEnabled() && this._transport) {\n      return this._transport.send(envelope).then(null, reason => {\n        DEBUG_BUILD && logger.error('Error while sending event:', reason);\n      });\n    } else {\n      DEBUG_BUILD && logger.error('Transport disabled');\n    }\n  }\n\n  /**\n   * Clears outcomes on this client and returns them.\n   */\n  _clearOutcomes() {\n    const outcomes = this._outcomes;\n    this._outcomes = {};\n    return Object.keys(outcomes).map(key => {\n      const [reason, category] = key.split(':');\n      return {\n        reason,\n        category,\n        quantity: outcomes[key]\n      };\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n}\n\n/**\n * Verifies that return value of configured `beforeSend` or `beforeSendTransaction` is of expected type, and returns the value if so.\n */\nfunction _validateBeforeSendResult(beforeSendResult, beforeSendLabel) {\n  const invalidValueError = `${beforeSendLabel} must return \\`null\\` or a valid event.`;\n  if (isThenable(beforeSendResult)) {\n    return beforeSendResult.then(event => {\n      if (!isPlainObject(event) && event !== null) {\n        throw new SentryError(invalidValueError);\n      }\n      return event;\n    }, e => {\n      throw new SentryError(`${beforeSendLabel} rejected with ${e}`);\n    });\n  } else if (!isPlainObject(beforeSendResult) && beforeSendResult !== null) {\n    throw new SentryError(invalidValueError);\n  }\n  return beforeSendResult;\n}\n\n/**\n * Process the matching `beforeSendXXX` callback.\n */\nfunction processBeforeSend(options, event, hint) {\n  const {\n    beforeSend,\n    beforeSendTransaction\n  } = options;\n  if (isErrorEvent(event) && beforeSend) {\n    return beforeSend(event, hint);\n  }\n  if (isTransactionEvent(event) && beforeSendTransaction) {\n    if (event.spans) {\n      // We store the # of spans before processing in SDK metadata,\n      // so we can compare it afterwards to determine how many spans were dropped\n      const spanCountBefore = event.spans.length;\n      event.sdkProcessingMetadata = {\n        ...event.sdkProcessingMetadata,\n        spanCountBeforeProcessing: spanCountBefore\n      };\n    }\n    return beforeSendTransaction(event, hint);\n  }\n  return event;\n}\nfunction isErrorEvent(event) {\n  return event.type === undefined;\n}\nfunction isTransactionEvent(event) {\n  return event.type === 'transaction';\n}\n\n/**\n * Add an event processor to the current client.\n * This event processor will run for all events processed by this client.\n */\nfunction addEventProcessor(callback) {\n  const client = getClient();\n  if (!client || !client.addEventProcessor) {\n    return;\n  }\n  client.addEventProcessor(callback);\n}\nexport { BaseClient, addEventProcessor };","map":{"version":3,"names":["ALREADY_SEEN_ERROR","BaseClient","constructor","options","_options","_integrations","_integrationsInitialized","_numProcessing","_outcomes","_hooks","_eventProcessors","dsn","_dsn","makeDsn","DEBUG_BUILD","logger","warn","url","getEnvelopeEndpointWithUrlEncodedAuth","_transport","transport","tunnel","recordDroppedEvent","bind","transportOptions","captureException","exception","hint","scope","checkOrSetAlreadyCaught","log","eventId","event_id","_process","eventFromException","then","event","_captureEvent","result","captureMessage","message","level","eventMessage","isParameterizedString","String","promisedEvent","isPrimitive","eventFromMessage","captureEvent","originalException","sdkProcessingMetadata","capturedSpanScope","captureSession","session","release","sendSession","updateSession","init","getDsn","getOptions","getSdkMetadata","_metadata","getTransport","flush","timeout","metricsAggregator","_isClientDoneProcessing","clientFinished","transportFlushed","resolvedSyncPromise","close","enabled","getEventProcessors","addEventProcessor","eventProcessor","push","setupIntegrations","forceInitialize","_isEnabled","_setupIntegrations","getIntegrationById","integrationId","getIntegrationByName","integrationName","getIntegration","integration","id","_oO","addIntegration","isAlreadyInstalled","name","setupIntegration","afterSetupIntegrations","sendEvent","arguments","length","undefined","emit","env","createEventEnvelope","attachment","attachments","addItemToEnvelope","createAttachmentEnvelopeItem","textEncoder","promise","_sendEnvelope","sendResponse","createSessionEnvelope","reason","category","eventOrCount","sendClientReports","count","key","captureAggregateMetrics","metricBucketItems","metricsEnvelope","createMetricEnvelope","on","hook","callback","_len","rest","Array","_key","forEach","integrations","_updateSessionFromEvent","crashed","errored","exceptions","values","ex","mechanism","handled","sessionNonTerminal","status","shouldUpdateAndSend","errors","Number","SyncPromise","resolve","ticked","tick","interval","setInterval","clearInterval","_prepareEvent","isolationScope","getIsolationScope","Object","keys","prepareEvent","evt","propagationContext","getPropagationContext","trace","contexts","traceId","trace_id","spanId","parentSpanId","dsc","span_id","parent_span_id","dynamicSamplingContext","getDynamicSamplingContextFromClient","_processEvent","finalEvent","sentryError","logLevel","sampleRate","isTransaction","isTransactionEvent","isError","isErrorEvent","eventType","type","beforeSendLabel","Math","random","rejectedSyncPromise","SentryError","dataCategory","capturedSpanIsolationScope","prepared","isInternalException","data","__sentry__","processBeforeSend","_validateBeforeSendResult","processedEvent","spans","spanCount","getSession","spanCountBefore","spanCountBeforeProcessing","spanCountAfter","droppedSpanCount","transactionInfo","transaction_info","transaction","source","value","envelope","send","error","_clearOutcomes","outcomes","map","split","quantity","beforeSendResult","invalidValueError","isThenable","isPlainObject","e","beforeSend","beforeSendTransaction","client","getClient"],"sources":["/Users/jeffreydebolt/Documents/fifo/cogs-dashboard/node_modules/@sentry/src/baseclient.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport type {\n  Breadcrumb,\n  BreadcrumbHint,\n  Client,\n  ClientOptions,\n  DataCategory,\n  DsnComponents,\n  DynamicSamplingContext,\n  Envelope,\n  ErrorEvent,\n  Event,\n  EventDropReason,\n  EventHint,\n  EventProcessor,\n  FeedbackEvent,\n  Integration,\n  IntegrationClass,\n  MetricBucketItem,\n  MetricsAggregator,\n  Outcome,\n  ParameterizedString,\n  SdkMetadata,\n  Session,\n  SessionAggregates,\n  Severity,\n  SeverityLevel,\n  StartSpanOptions,\n  Transaction,\n  TransactionEvent,\n  Transport,\n  TransportMakeRequestResponse,\n} from '@sentry/types';\nimport {\n  SentryError,\n  SyncPromise,\n  addItemToEnvelope,\n  checkOrSetAlreadyCaught,\n  createAttachmentEnvelopeItem,\n  isParameterizedString,\n  isPlainObject,\n  isPrimitive,\n  isThenable,\n  logger,\n  makeDsn,\n  rejectedSyncPromise,\n  resolvedSyncPromise,\n} from '@sentry/utils';\n\nimport { getEnvelopeEndpointWithUrlEncodedAuth } from './api';\nimport { DEBUG_BUILD } from './debug-build';\nimport { createEventEnvelope, createSessionEnvelope } from './envelope';\nimport { getClient } from './exports';\nimport { getIsolationScope } from './hub';\nimport type { IntegrationIndex } from './integration';\nimport { afterSetupIntegrations } from './integration';\nimport { setupIntegration, setupIntegrations } from './integration';\nimport { createMetricEnvelope } from './metrics/envelope';\nimport type { Scope } from './scope';\nimport { updateSession } from './session';\nimport { getDynamicSamplingContextFromClient } from './tracing/dynamicSamplingContext';\nimport { prepareEvent } from './utils/prepareEvent';\n\nconst ALREADY_SEEN_ERROR = \"Not capturing exception because it's already been captured.\";\n\n/**\n * Base implementation for all JavaScript SDK clients.\n *\n * Call the constructor with the corresponding options\n * specific to the client subclass. To access these options later, use\n * {@link Client.getOptions}.\n *\n * If a Dsn is specified in the options, it will be parsed and stored. Use\n * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is\n * invalid, the constructor will throw a {@link SentryException}. Note that\n * without a valid Dsn, the SDK will not send any events to Sentry.\n *\n * Before sending an event, it is passed through\n * {@link BaseClient._prepareEvent} to add SDK information and scope data\n * (breadcrumbs and context). To add more custom information, override this\n * method and extend the resulting prepared event.\n *\n * To issue automatically created events (e.g. via instrumentation), use\n * {@link Client.captureEvent}. It will prepare the event and pass it through\n * the callback lifecycle. To issue auto-breadcrumbs, use\n * {@link Client.addBreadcrumb}.\n *\n * @example\n * class NodeClient extends BaseClient<NodeOptions> {\n *   public constructor(options: NodeOptions) {\n *     super(options);\n *   }\n *\n *   // ...\n * }\n */\nexport abstract class BaseClient<O extends ClientOptions> implements Client<O> {\n  /**\n   * A reference to a metrics aggregator\n   *\n   * @experimental Note this is alpha API. It may experience breaking changes in the future.\n   */\n  public metricsAggregator?: MetricsAggregator;\n\n  /** Options passed to the SDK. */\n  protected readonly _options: O;\n\n  /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */\n  protected readonly _dsn?: DsnComponents;\n\n  protected readonly _transport?: Transport;\n\n  /** Array of set up integrations. */\n  protected _integrations: IntegrationIndex;\n\n  /** Indicates whether this client's integrations have been set up. */\n  protected _integrationsInitialized: boolean;\n\n  /** Number of calls being processed */\n  protected _numProcessing: number;\n\n  protected _eventProcessors: EventProcessor[];\n\n  /** Holds flushable  */\n  private _outcomes: { [key: string]: number };\n\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  private _hooks: Record<string, Function[]>;\n\n  /**\n   * Initializes this client instance.\n   *\n   * @param options Options for the client.\n   */\n  protected constructor(options: O) {\n    this._options = options;\n    this._integrations = {};\n    this._integrationsInitialized = false;\n    this._numProcessing = 0;\n    this._outcomes = {};\n    this._hooks = {};\n    this._eventProcessors = [];\n\n    if (options.dsn) {\n      this._dsn = makeDsn(options.dsn);\n    } else {\n      DEBUG_BUILD && logger.warn('No DSN provided, client will not send events.');\n    }\n\n    if (this._dsn) {\n      const url = getEnvelopeEndpointWithUrlEncodedAuth(this._dsn, options);\n      this._transport = options.transport({\n        tunnel: this._options.tunnel,\n        recordDroppedEvent: this.recordDroppedEvent.bind(this),\n        ...options.transportOptions,\n        url,\n      });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n  public captureException(exception: any, hint?: EventHint, scope?: Scope): string | undefined {\n    // ensure we haven't captured this very object before\n    if (checkOrSetAlreadyCaught(exception)) {\n      DEBUG_BUILD && logger.log(ALREADY_SEEN_ERROR);\n      return;\n    }\n\n    let eventId: string | undefined = hint && hint.event_id;\n\n    this._process(\n      this.eventFromException(exception, hint)\n        .then(event => this._captureEvent(event, hint, scope))\n        .then(result => {\n          eventId = result;\n        }),\n    );\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureMessage(\n    message: ParameterizedString,\n    // eslint-disable-next-line deprecation/deprecation\n    level?: Severity | SeverityLevel,\n    hint?: EventHint,\n    scope?: Scope,\n  ): string | undefined {\n    let eventId: string | undefined = hint && hint.event_id;\n\n    const eventMessage = isParameterizedString(message) ? message : String(message);\n\n    const promisedEvent = isPrimitive(message)\n      ? this.eventFromMessage(eventMessage, level, hint)\n      : this.eventFromException(message, hint);\n\n    this._process(\n      promisedEvent\n        .then(event => this._captureEvent(event, hint, scope))\n        .then(result => {\n          eventId = result;\n        }),\n    );\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureEvent(event: Event, hint?: EventHint, scope?: Scope): string | undefined {\n    // ensure we haven't captured this very object before\n    if (hint && hint.originalException && checkOrSetAlreadyCaught(hint.originalException)) {\n      DEBUG_BUILD && logger.log(ALREADY_SEEN_ERROR);\n      return;\n    }\n\n    let eventId: string | undefined = hint && hint.event_id;\n\n    const sdkProcessingMetadata = event.sdkProcessingMetadata || {};\n    const capturedSpanScope: Scope | undefined = sdkProcessingMetadata.capturedSpanScope;\n\n    this._process(\n      this._captureEvent(event, hint, capturedSpanScope || scope).then(result => {\n        eventId = result;\n      }),\n    );\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureSession(session: Session): void {\n    if (!(typeof session.release === 'string')) {\n      DEBUG_BUILD && logger.warn('Discarded session because of missing or non-string release');\n    } else {\n      this.sendSession(session);\n      // After sending, we set init false to indicate it's not the first occurrence\n      updateSession(session, { init: false });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getDsn(): DsnComponents | undefined {\n    return this._dsn;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getOptions(): O {\n    return this._options;\n  }\n\n  /**\n   * @see SdkMetadata in @sentry/types\n   *\n   * @return The metadata of the SDK\n   */\n  public getSdkMetadata(): SdkMetadata | undefined {\n    return this._options._metadata;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getTransport(): Transport | undefined {\n    return this._transport;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public flush(timeout?: number): PromiseLike<boolean> {\n    const transport = this._transport;\n    if (transport) {\n      if (this.metricsAggregator) {\n        this.metricsAggregator.flush();\n      }\n      return this._isClientDoneProcessing(timeout).then(clientFinished => {\n        return transport.flush(timeout).then(transportFlushed => clientFinished && transportFlushed);\n      });\n    } else {\n      return resolvedSyncPromise(true);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public close(timeout?: number): PromiseLike<boolean> {\n    return this.flush(timeout).then(result => {\n      this.getOptions().enabled = false;\n      if (this.metricsAggregator) {\n        this.metricsAggregator.close();\n      }\n      return result;\n    });\n  }\n\n  /** Get all installed event processors. */\n  public getEventProcessors(): EventProcessor[] {\n    return this._eventProcessors;\n  }\n\n  /** @inheritDoc */\n  public addEventProcessor(eventProcessor: EventProcessor): void {\n    this._eventProcessors.push(eventProcessor);\n  }\n\n  /**\n   * This is an internal function to setup all integrations that should run on the client.\n   * @deprecated Use `client.init()` instead.\n   */\n  public setupIntegrations(forceInitialize?: boolean): void {\n    if ((forceInitialize && !this._integrationsInitialized) || (this._isEnabled() && !this._integrationsInitialized)) {\n      this._setupIntegrations();\n    }\n  }\n\n  /** @inheritdoc */\n  public init(): void {\n    if (this._isEnabled()) {\n      this._setupIntegrations();\n    }\n  }\n\n  /**\n   * Gets an installed integration by its `id`.\n   *\n   * @returns The installed integration or `undefined` if no integration with that `id` was installed.\n   * @deprecated Use `getIntegrationByName()` instead.\n   */\n  public getIntegrationById(integrationId: string): Integration | undefined {\n    return this.getIntegrationByName(integrationId);\n  }\n\n  /**\n   * Gets an installed integration by its name.\n   *\n   * @returns The installed integration or `undefined` if no integration with that `name` was installed.\n   */\n  public getIntegrationByName<T extends Integration = Integration>(integrationName: string): T | undefined {\n    return this._integrations[integrationName] as T | undefined;\n  }\n\n  /**\n   * Returns the client's instance of the given integration class, it any.\n   * @deprecated Use `getIntegrationByName()` instead.\n   */\n  public getIntegration<T extends Integration>(integration: IntegrationClass<T>): T | null {\n    try {\n      return (this._integrations[integration.id] as T) || null;\n    } catch (_oO) {\n      DEBUG_BUILD && logger.warn(`Cannot retrieve integration ${integration.id} from the current Client`);\n      return null;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public addIntegration(integration: Integration): void {\n    const isAlreadyInstalled = this._integrations[integration.name];\n\n    // This hook takes care of only installing if not already installed\n    setupIntegration(this, integration, this._integrations);\n    // Here we need to check manually to make sure to not run this multiple times\n    if (!isAlreadyInstalled) {\n      afterSetupIntegrations(this, [integration]);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public sendEvent(event: Event, hint: EventHint = {}): void {\n    this.emit('beforeSendEvent', event, hint);\n\n    let env = createEventEnvelope(event, this._dsn, this._options._metadata, this._options.tunnel);\n\n    for (const attachment of hint.attachments || []) {\n      env = addItemToEnvelope(\n        env,\n        createAttachmentEnvelopeItem(\n          attachment,\n          this._options.transportOptions && this._options.transportOptions.textEncoder,\n        ),\n      );\n    }\n\n    const promise = this._sendEnvelope(env);\n    if (promise) {\n      promise.then(sendResponse => this.emit('afterSendEvent', event, sendResponse), null);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public sendSession(session: Session | SessionAggregates): void {\n    const env = createSessionEnvelope(session, this._dsn, this._options._metadata, this._options.tunnel);\n\n    // _sendEnvelope should not throw\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this._sendEnvelope(env);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public recordDroppedEvent(reason: EventDropReason, category: DataCategory, eventOrCount?: Event | number): void {\n    if (this._options.sendClientReports) {\n      // TODO v9: We do not need the `event` passed as third argument anymore, and can possibly remove this overload\n      // If event is passed as third argument, we assume this is a count of 1\n      const count = typeof eventOrCount === 'number' ? eventOrCount : 1;\n\n      // We want to track each category (error, transaction, session, replay_event) separately\n      // but still keep the distinction between different type of outcomes.\n      // We could use nested maps, but it's much easier to read and type this way.\n      // A correct type for map-based implementation if we want to go that route\n      // would be `Partial<Record<SentryRequestType, Partial<Record<Outcome, number>>>>`\n      // With typescript 4.1 we could even use template literal types\n      const key = `${reason}:${category}`;\n      DEBUG_BUILD && logger.log(`Recording outcome: \"${key}\"${count > 1 ? ` (${count} times)` : ''}`);\n      this._outcomes[key] = (this._outcomes[key] || 0) + count;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureAggregateMetrics(metricBucketItems: Array<MetricBucketItem>): void {\n    DEBUG_BUILD && logger.log(`Flushing aggregated metrics, number of metrics: ${metricBucketItems.length}`);\n    const metricsEnvelope = createMetricEnvelope(\n      metricBucketItems,\n      this._dsn,\n      this._options._metadata,\n      this._options.tunnel,\n    );\n\n    // _sendEnvelope should not throw\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this._sendEnvelope(metricsEnvelope);\n  }\n\n  // Keep on() & emit() signatures in sync with types' client.ts interface\n  /* eslint-disable @typescript-eslint/unified-signatures */\n\n  /** @inheritdoc */\n  public on(hook: 'startTransaction', callback: (transaction: Transaction) => void): void;\n\n  /** @inheritdoc */\n  public on(hook: 'finishTransaction', callback: (transaction: Transaction) => void): void;\n\n  /** @inheritdoc */\n  public on(hook: 'beforeEnvelope', callback: (envelope: Envelope) => void): void;\n\n  /** @inheritdoc */\n  public on(hook: 'beforeSendEvent', callback: (event: Event, hint?: EventHint) => void): void;\n\n  /** @inheritdoc */\n  public on(hook: 'preprocessEvent', callback: (event: Event, hint?: EventHint) => void): void;\n\n  /** @inheritdoc */\n  public on(\n    hook: 'afterSendEvent',\n    callback: (event: Event, sendResponse: TransportMakeRequestResponse | void) => void,\n  ): void;\n\n  /** @inheritdoc */\n  public on(hook: 'beforeAddBreadcrumb', callback: (breadcrumb: Breadcrumb, hint?: BreadcrumbHint) => void): void;\n\n  /** @inheritdoc */\n  public on(hook: 'createDsc', callback: (dsc: DynamicSamplingContext) => void): void;\n\n  /** @inheritdoc */\n  public on(hook: 'otelSpanEnd', callback: (otelSpan: unknown, mutableOptions: { drop: boolean }) => void): void;\n\n  /** @inheritdoc */\n  public on(\n    hook: 'beforeSendFeedback',\n    callback: (feedback: FeedbackEvent, options?: { includeReplay: boolean }) => void,\n  ): void;\n\n  /** @inheritdoc */\n  public on(hook: 'startPageLoadSpan', callback: (options: StartSpanOptions) => void): void;\n\n  /** @inheritdoc */\n  public on(hook: 'startNavigationSpan', callback: (options: StartSpanOptions) => void): void;\n\n  /** @inheritdoc */\n  public on(hook: string, callback: unknown): void {\n    if (!this._hooks[hook]) {\n      this._hooks[hook] = [];\n    }\n\n    // @ts-expect-error We assue the types are correct\n    this._hooks[hook].push(callback);\n  }\n\n  /** @inheritdoc */\n  public emit(hook: 'startTransaction', transaction: Transaction): void;\n\n  /** @inheritdoc */\n  public emit(hook: 'finishTransaction', transaction: Transaction): void;\n\n  /** @inheritdoc */\n  public emit(hook: 'beforeEnvelope', envelope: Envelope): void;\n\n  /** @inheritdoc */\n  public emit(hook: 'beforeSendEvent', event: Event, hint?: EventHint): void;\n\n  /** @inheritdoc */\n  public emit(hook: 'preprocessEvent', event: Event, hint?: EventHint): void;\n\n  /** @inheritdoc */\n  public emit(hook: 'afterSendEvent', event: Event, sendResponse: TransportMakeRequestResponse | void): void;\n\n  /** @inheritdoc */\n  public emit(hook: 'beforeAddBreadcrumb', breadcrumb: Breadcrumb, hint?: BreadcrumbHint): void;\n\n  /** @inheritdoc */\n  public emit(hook: 'createDsc', dsc: DynamicSamplingContext): void;\n\n  /** @inheritdoc */\n  public emit(hook: 'otelSpanEnd', otelSpan: unknown, mutableOptions: { drop: boolean }): void;\n\n  /** @inheritdoc */\n  public emit(hook: 'beforeSendFeedback', feedback: FeedbackEvent, options?: { includeReplay: boolean }): void;\n\n  /** @inheritdoc */\n  public emit(hook: 'startPageLoadSpan', options: StartSpanOptions): void;\n\n  /** @inheritdoc */\n  public emit(hook: 'startNavigationSpan', options: StartSpanOptions): void;\n\n  /** @inheritdoc */\n  public emit(hook: string, ...rest: unknown[]): void {\n    if (this._hooks[hook]) {\n      this._hooks[hook].forEach(callback => callback(...rest));\n    }\n  }\n\n  /* eslint-enable @typescript-eslint/unified-signatures */\n\n  /** Setup integrations for this client. */\n  protected _setupIntegrations(): void {\n    const { integrations } = this._options;\n    this._integrations = setupIntegrations(this, integrations);\n    afterSetupIntegrations(this, integrations);\n\n    // TODO v8: We don't need this flag anymore\n    this._integrationsInitialized = true;\n  }\n\n  /** Updates existing session based on the provided event */\n  protected _updateSessionFromEvent(session: Session, event: Event): void {\n    let crashed = false;\n    let errored = false;\n    const exceptions = event.exception && event.exception.values;\n\n    if (exceptions) {\n      errored = true;\n\n      for (const ex of exceptions) {\n        const mechanism = ex.mechanism;\n        if (mechanism && mechanism.handled === false) {\n          crashed = true;\n          break;\n        }\n      }\n    }\n\n    // A session is updated and that session update is sent in only one of the two following scenarios:\n    // 1. Session with non terminal status and 0 errors + an error occurred -> Will set error count to 1 and send update\n    // 2. Session with non terminal status and 1 error + a crash occurred -> Will set status crashed and send update\n    const sessionNonTerminal = session.status === 'ok';\n    const shouldUpdateAndSend = (sessionNonTerminal && session.errors === 0) || (sessionNonTerminal && crashed);\n\n    if (shouldUpdateAndSend) {\n      updateSession(session, {\n        ...(crashed && { status: 'crashed' }),\n        errors: session.errors || Number(errored || crashed),\n      });\n      this.captureSession(session);\n    }\n  }\n\n  /**\n   * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying\n   * \"no\" (resolving to `false`) in order to give the client a chance to potentially finish first.\n   *\n   * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not\n   * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to\n   * `true`.\n   * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and\n   * `false` otherwise\n   */\n  protected _isClientDoneProcessing(timeout?: number): PromiseLike<boolean> {\n    return new SyncPromise(resolve => {\n      let ticked: number = 0;\n      const tick: number = 1;\n\n      const interval = setInterval(() => {\n        if (this._numProcessing == 0) {\n          clearInterval(interval);\n          resolve(true);\n        } else {\n          ticked += tick;\n          if (timeout && ticked >= timeout) {\n            clearInterval(interval);\n            resolve(false);\n          }\n        }\n      }, tick);\n    });\n  }\n\n  /** Determines whether this SDK is enabled and a transport is present. */\n  protected _isEnabled(): boolean {\n    return this.getOptions().enabled !== false && this._transport !== undefined;\n  }\n\n  /**\n   * Adds common information to events.\n   *\n   * The information includes release and environment from `options`,\n   * breadcrumbs and context (extra, tags and user) from the scope.\n   *\n   * Information that is already present in the event is never overwritten. For\n   * nested objects, such as the context, keys are merged.\n   *\n   * @param event The original event.\n   * @param hint May contain additional information about the original exception.\n   * @param scope A scope containing event metadata.\n   * @returns A new event with more information.\n   */\n  protected _prepareEvent(\n    event: Event,\n    hint: EventHint,\n    scope?: Scope,\n    isolationScope = getIsolationScope(),\n  ): PromiseLike<Event | null> {\n    const options = this.getOptions();\n    const integrations = Object.keys(this._integrations);\n    if (!hint.integrations && integrations.length > 0) {\n      hint.integrations = integrations;\n    }\n\n    this.emit('preprocessEvent', event, hint);\n\n    return prepareEvent(options, event, hint, scope, this, isolationScope).then(evt => {\n      if (evt === null) {\n        return evt;\n      }\n\n      const propagationContext = {\n        ...isolationScope.getPropagationContext(),\n        ...(scope ? scope.getPropagationContext() : undefined),\n      };\n\n      const trace = evt.contexts && evt.contexts.trace;\n      if (!trace && propagationContext) {\n        const { traceId: trace_id, spanId, parentSpanId, dsc } = propagationContext;\n        evt.contexts = {\n          trace: {\n            trace_id,\n            span_id: spanId,\n            parent_span_id: parentSpanId,\n          },\n          ...evt.contexts,\n        };\n\n        const dynamicSamplingContext = dsc ? dsc : getDynamicSamplingContextFromClient(trace_id, this, scope);\n\n        evt.sdkProcessingMetadata = {\n          dynamicSamplingContext,\n          ...evt.sdkProcessingMetadata,\n        };\n      }\n      return evt;\n    });\n  }\n\n  /**\n   * Processes the event and logs an error in case of rejection\n   * @param event\n   * @param hint\n   * @param scope\n   */\n  protected _captureEvent(event: Event, hint: EventHint = {}, scope?: Scope): PromiseLike<string | undefined> {\n    return this._processEvent(event, hint, scope).then(\n      finalEvent => {\n        return finalEvent.event_id;\n      },\n      reason => {\n        if (DEBUG_BUILD) {\n          // If something's gone wrong, log the error as a warning. If it's just us having used a `SentryError` for\n          // control flow, log just the message (no stack) as a log-level log.\n          const sentryError = reason as SentryError;\n          if (sentryError.logLevel === 'log') {\n            logger.log(sentryError.message);\n          } else {\n            logger.warn(sentryError);\n          }\n        }\n        return undefined;\n      },\n    );\n  }\n\n  /**\n   * Processes an event (either error or message) and sends it to Sentry.\n   *\n   * This also adds breadcrumbs and context information to the event. However,\n   * platform specific meta data (such as the User's IP address) must be added\n   * by the SDK implementor.\n   *\n   *\n   * @param event The event to send to Sentry.\n   * @param hint May contain additional information about the original exception.\n   * @param scope A scope containing event metadata.\n   * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.\n   */\n  protected _processEvent(event: Event, hint: EventHint, scope?: Scope): PromiseLike<Event> {\n    const options = this.getOptions();\n    const { sampleRate } = options;\n\n    const isTransaction = isTransactionEvent(event);\n    const isError = isErrorEvent(event);\n    const eventType = event.type || 'error';\n    const beforeSendLabel = `before send for type \\`${eventType}\\``;\n\n    // 1.0 === 100% events are sent\n    // 0.0 === 0% events are sent\n    // Sampling for transaction happens somewhere else\n    if (isError && typeof sampleRate === 'number' && Math.random() > sampleRate) {\n      this.recordDroppedEvent('sample_rate', 'error', event);\n      return rejectedSyncPromise(\n        new SentryError(\n          `Discarding event because it's not included in the random sample (sampling rate = ${sampleRate})`,\n          'log',\n        ),\n      );\n    }\n\n    const dataCategory: DataCategory = eventType === 'replay_event' ? 'replay' : eventType;\n\n    const sdkProcessingMetadata = event.sdkProcessingMetadata || {};\n    const capturedSpanIsolationScope: Scope | undefined = sdkProcessingMetadata.capturedSpanIsolationScope;\n\n    return this._prepareEvent(event, hint, scope, capturedSpanIsolationScope)\n      .then(prepared => {\n        if (prepared === null) {\n          this.recordDroppedEvent('event_processor', dataCategory, event);\n          throw new SentryError('An event processor returned `null`, will not send event.', 'log');\n        }\n\n        const isInternalException = hint.data && (hint.data as { __sentry__: boolean }).__sentry__ === true;\n        if (isInternalException) {\n          return prepared;\n        }\n\n        const result = processBeforeSend(options, prepared, hint);\n        return _validateBeforeSendResult(result, beforeSendLabel);\n      })\n      .then(processedEvent => {\n        if (processedEvent === null) {\n          this.recordDroppedEvent('before_send', dataCategory, event);\n          if (isTransaction) {\n            const spans = event.spans || [];\n            // the transaction itself counts as one span, plus all the child spans that are added\n            const spanCount = 1 + spans.length;\n            this.recordDroppedEvent('before_send', 'span', spanCount);\n          }\n          throw new SentryError(`${beforeSendLabel} returned \\`null\\`, will not send event.`, 'log');\n        }\n\n        const session = scope && scope.getSession();\n        if (!isTransaction && session) {\n          this._updateSessionFromEvent(session, processedEvent);\n        }\n\n        if (isTransaction) {\n          const spanCountBefore =\n            (processedEvent.sdkProcessingMetadata && processedEvent.sdkProcessingMetadata.spanCountBeforeProcessing) ||\n            0;\n          const spanCountAfter = processedEvent.spans ? processedEvent.spans.length : 0;\n\n          const droppedSpanCount = spanCountBefore - spanCountAfter;\n          if (droppedSpanCount > 0) {\n            this.recordDroppedEvent('before_send', 'span', droppedSpanCount);\n          }\n        }\n\n        // None of the Sentry built event processor will update transaction name,\n        // so if the transaction name has been changed by an event processor, we know\n        // it has to come from custom event processor added by a user\n        const transactionInfo = processedEvent.transaction_info;\n        if (isTransaction && transactionInfo && processedEvent.transaction !== event.transaction) {\n          const source = 'custom';\n          processedEvent.transaction_info = {\n            ...transactionInfo,\n            source,\n          };\n        }\n\n        this.sendEvent(processedEvent, hint);\n        return processedEvent;\n      })\n      .then(null, reason => {\n        if (reason instanceof SentryError) {\n          throw reason;\n        }\n\n        this.captureException(reason, {\n          data: {\n            __sentry__: true,\n          },\n          originalException: reason,\n        });\n        throw new SentryError(\n          `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\\nReason: ${reason}`,\n        );\n      });\n  }\n\n  /**\n   * Occupies the client with processing and event\n   */\n  protected _process<T>(promise: PromiseLike<T>): void {\n    this._numProcessing++;\n    void promise.then(\n      value => {\n        this._numProcessing--;\n        return value;\n      },\n      reason => {\n        this._numProcessing--;\n        return reason;\n      },\n    );\n  }\n\n  /**\n   * @inheritdoc\n   */\n  protected _sendEnvelope(envelope: Envelope): PromiseLike<void | TransportMakeRequestResponse> | void {\n    this.emit('beforeEnvelope', envelope);\n\n    if (this._isEnabled() && this._transport) {\n      return this._transport.send(envelope).then(null, reason => {\n        DEBUG_BUILD && logger.error('Error while sending event:', reason);\n      });\n    } else {\n      DEBUG_BUILD && logger.error('Transport disabled');\n    }\n  }\n\n  /**\n   * Clears outcomes on this client and returns them.\n   */\n  protected _clearOutcomes(): Outcome[] {\n    const outcomes = this._outcomes;\n    this._outcomes = {};\n    return Object.keys(outcomes).map(key => {\n      const [reason, category] = key.split(':') as [EventDropReason, DataCategory];\n      return {\n        reason,\n        category,\n        quantity: outcomes[key],\n      };\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n  public abstract eventFromException(_exception: any, _hint?: EventHint): PromiseLike<Event>;\n\n  /**\n   * @inheritDoc\n   */\n  public abstract eventFromMessage(\n    _message: ParameterizedString,\n    // eslint-disable-next-line deprecation/deprecation\n    _level?: Severity | SeverityLevel,\n    _hint?: EventHint,\n  ): PromiseLike<Event>;\n}\n\n/**\n * Verifies that return value of configured `beforeSend` or `beforeSendTransaction` is of expected type, and returns the value if so.\n */\nfunction _validateBeforeSendResult(\n  beforeSendResult: PromiseLike<Event | null> | Event | null,\n  beforeSendLabel: string,\n): PromiseLike<Event | null> | Event | null {\n  const invalidValueError = `${beforeSendLabel} must return \\`null\\` or a valid event.`;\n  if (isThenable(beforeSendResult)) {\n    return beforeSendResult.then(\n      event => {\n        if (!isPlainObject(event) && event !== null) {\n          throw new SentryError(invalidValueError);\n        }\n        return event;\n      },\n      e => {\n        throw new SentryError(`${beforeSendLabel} rejected with ${e}`);\n      },\n    );\n  } else if (!isPlainObject(beforeSendResult) && beforeSendResult !== null) {\n    throw new SentryError(invalidValueError);\n  }\n  return beforeSendResult;\n}\n\n/**\n * Process the matching `beforeSendXXX` callback.\n */\nfunction processBeforeSend(\n  options: ClientOptions,\n  event: Event,\n  hint: EventHint,\n): PromiseLike<Event | null> | Event | null {\n  const { beforeSend, beforeSendTransaction } = options;\n\n  if (isErrorEvent(event) && beforeSend) {\n    return beforeSend(event, hint);\n  }\n\n  if (isTransactionEvent(event) && beforeSendTransaction) {\n    if (event.spans) {\n      // We store the # of spans before processing in SDK metadata,\n      // so we can compare it afterwards to determine how many spans were dropped\n      const spanCountBefore = event.spans.length;\n      event.sdkProcessingMetadata = {\n        ...event.sdkProcessingMetadata,\n        spanCountBeforeProcessing: spanCountBefore,\n      };\n    }\n    return beforeSendTransaction(event, hint);\n  }\n\n  return event;\n}\n\nfunction isErrorEvent(event: Event): event is ErrorEvent {\n  return event.type === undefined;\n}\n\nfunction isTransactionEvent(event: Event): event is TransactionEvent {\n  return event.type === 'transaction';\n}\n\n/**\n * Add an event processor to the current client.\n * This event processor will run for all events processed by this client.\n */\nexport function addEventProcessor(callback: EventProcessor): void {\n  const client = getClient();\n\n  if (!client || !client.addEventProcessor) {\n    return;\n  }\n\n  client.addEventProcessor(callback);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}