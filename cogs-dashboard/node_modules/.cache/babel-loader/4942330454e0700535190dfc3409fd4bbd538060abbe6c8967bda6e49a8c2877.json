{"ast":null,"code":"import { timestampInSeconds } from '@sentry/utils';\nimport { DEFAULT_BROWSER_FLUSH_INTERVAL, SET_METRIC_TYPE } from './constants.js';\nimport { METRIC_MAP } from './instance.js';\nimport { updateMetricSummaryOnActiveSpan } from './metric-summary.js';\nimport { sanitizeMetricKey, sanitizeTags, sanitizeUnit, getBucketKey } from './utils.js';\n\n/**\n * A simple metrics aggregator that aggregates metrics in memory and flushes them periodically.\n * Default flush interval is 5 seconds.\n *\n * @experimental This API is experimental and might change in the future.\n */\nclass BrowserMetricsAggregator {\n  // TODO(@anonrig): Use FinalizationRegistry to have a proper way of flushing the buckets\n  // when the aggregator is garbage collected.\n  // Ref: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry\n\n  constructor(_client) {\n    this._client = _client;\n    this._buckets = new Map();\n    this._interval = setInterval(() => this.flush(), DEFAULT_BROWSER_FLUSH_INTERVAL);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  add(metricType, unsanitizedName, value, unsanitizedUnit = 'none', unsanitizedTags = {}, maybeFloatTimestamp = timestampInSeconds()) {\n    const timestamp = Math.floor(maybeFloatTimestamp);\n    const name = sanitizeMetricKey(unsanitizedName);\n    const tags = sanitizeTags(unsanitizedTags);\n    const unit = sanitizeUnit(unsanitizedUnit);\n    const bucketKey = getBucketKey(metricType, name, unit, tags);\n    let bucketItem = this._buckets.get(bucketKey);\n    // If this is a set metric, we need to calculate the delta from the previous weight.\n    const previousWeight = bucketItem && metricType === SET_METRIC_TYPE ? bucketItem.metric.weight : 0;\n    if (bucketItem) {\n      bucketItem.metric.add(value);\n      // TODO(abhi): Do we need this check?\n      if (bucketItem.timestamp < timestamp) {\n        bucketItem.timestamp = timestamp;\n      }\n    } else {\n      bucketItem = {\n        // @ts-expect-error we don't need to narrow down the type of value here, saves bundle size.\n        metric: new METRIC_MAP[metricType](value),\n        timestamp,\n        metricType,\n        name,\n        unit,\n        tags\n      };\n      this._buckets.set(bucketKey, bucketItem);\n    }\n\n    // If value is a string, it's a set metric so calculate the delta from the previous weight.\n    const val = typeof value === 'string' ? bucketItem.metric.weight - previousWeight : value;\n    updateMetricSummaryOnActiveSpan(metricType, name, val, unit, unsanitizedTags, bucketKey);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  flush() {\n    // short circuit if buckets are empty.\n    if (this._buckets.size === 0) {\n      return;\n    }\n    if (this._client.captureAggregateMetrics) {\n      // TODO(@anonrig): Use Object.values() when we support ES6+\n      const metricBuckets = Array.from(this._buckets).map(([, bucketItem]) => bucketItem);\n      this._client.captureAggregateMetrics(metricBuckets);\n    }\n    this._buckets.clear();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  close() {\n    clearInterval(this._interval);\n    this.flush();\n  }\n}\nexport { BrowserMetricsAggregator };","map":{"version":3,"names":["BrowserMetricsAggregator","constructor","_client","_buckets","Map","_interval","setInterval","flush","DEFAULT_BROWSER_FLUSH_INTERVAL","add","metricType","unsanitizedName","value","unsanitizedUnit","unsanitizedTags","maybeFloatTimestamp","timestampInSeconds","timestamp","Math","floor","name","sanitizeMetricKey","tags","sanitizeTags","unit","sanitizeUnit","bucketKey","getBucketKey","bucketItem","get","previousWeight","SET_METRIC_TYPE","metric","weight","METRIC_MAP","set","val","updateMetricSummaryOnActiveSpan","size","captureAggregateMetrics","metricBuckets","Array","from","map","clear","close","clearInterval"],"sources":["/Users/jeffreydebolt/Documents/fifo/cogs-dashboard/node_modules/@sentry/src/metrics/browser-aggregator.ts"],"sourcesContent":["import type { Client, ClientOptions, MeasurementUnit, MetricsAggregator, Primitive } from '@sentry/types';\nimport { timestampInSeconds } from '@sentry/utils';\nimport { DEFAULT_BROWSER_FLUSH_INTERVAL, SET_METRIC_TYPE } from './constants';\nimport { METRIC_MAP } from './instance';\nimport { updateMetricSummaryOnActiveSpan } from './metric-summary';\nimport type { MetricBucket, MetricType } from './types';\nimport { getBucketKey, sanitizeMetricKey, sanitizeTags, sanitizeUnit } from './utils';\n\n/**\n * A simple metrics aggregator that aggregates metrics in memory and flushes them periodically.\n * Default flush interval is 5 seconds.\n *\n * @experimental This API is experimental and might change in the future.\n */\nexport class BrowserMetricsAggregator implements MetricsAggregator {\n  // TODO(@anonrig): Use FinalizationRegistry to have a proper way of flushing the buckets\n  // when the aggregator is garbage collected.\n  // Ref: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry\n  private _buckets: MetricBucket;\n  private readonly _interval: ReturnType<typeof setInterval>;\n\n  public constructor(private readonly _client: Client<ClientOptions>) {\n    this._buckets = new Map();\n    this._interval = setInterval(() => this.flush(), DEFAULT_BROWSER_FLUSH_INTERVAL);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public add(\n    metricType: MetricType,\n    unsanitizedName: string,\n    value: number | string,\n    unsanitizedUnit: MeasurementUnit | undefined = 'none',\n    unsanitizedTags: Record<string, Primitive> | undefined = {},\n    maybeFloatTimestamp: number | undefined = timestampInSeconds(),\n  ): void {\n    const timestamp = Math.floor(maybeFloatTimestamp);\n    const name = sanitizeMetricKey(unsanitizedName);\n    const tags = sanitizeTags(unsanitizedTags);\n    const unit = sanitizeUnit(unsanitizedUnit as string);\n\n    const bucketKey = getBucketKey(metricType, name, unit, tags);\n\n    let bucketItem = this._buckets.get(bucketKey);\n    // If this is a set metric, we need to calculate the delta from the previous weight.\n    const previousWeight = bucketItem && metricType === SET_METRIC_TYPE ? bucketItem.metric.weight : 0;\n\n    if (bucketItem) {\n      bucketItem.metric.add(value);\n      // TODO(abhi): Do we need this check?\n      if (bucketItem.timestamp < timestamp) {\n        bucketItem.timestamp = timestamp;\n      }\n    } else {\n      bucketItem = {\n        // @ts-expect-error we don't need to narrow down the type of value here, saves bundle size.\n        metric: new METRIC_MAP[metricType](value),\n        timestamp,\n        metricType,\n        name,\n        unit,\n        tags,\n      };\n      this._buckets.set(bucketKey, bucketItem);\n    }\n\n    // If value is a string, it's a set metric so calculate the delta from the previous weight.\n    const val = typeof value === 'string' ? bucketItem.metric.weight - previousWeight : value;\n    updateMetricSummaryOnActiveSpan(metricType, name, val, unit, unsanitizedTags, bucketKey);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public flush(): void {\n    // short circuit if buckets are empty.\n    if (this._buckets.size === 0) {\n      return;\n    }\n\n    if (this._client.captureAggregateMetrics) {\n      // TODO(@anonrig): Use Object.values() when we support ES6+\n      const metricBuckets = Array.from(this._buckets).map(([, bucketItem]) => bucketItem);\n      this._client.captureAggregateMetrics(metricBuckets);\n    }\n\n    this._buckets.clear();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public close(): void {\n    clearInterval(this._interval);\n    this.flush();\n  }\n}\n"],"mappings":";;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACO,MAAMA,wBAAA,CAAsD;EACnE;EACA;EACA;;EAISC,WAAWA,CAAkBC,OAAO,EAAyB;IAAA,KAAAA,OAAA,GAAAA,OAAA;IAClE,IAAI,CAACC,QAAA,GAAW,IAAIC,GAAG,EAAE;IACzB,IAAI,CAACC,SAAA,GAAYC,WAAW,CAAC,MAAM,IAAI,CAACC,KAAK,EAAE,EAAEC,8BAA8B,CAAC;EACpF;;EAEA;AACA;AACA;EACSC,GAAGA,CACRC,UAAU,EACVC,eAAe,EACfC,KAAK,EACLC,eAAe,GAAgC,MAAM,EACrDC,eAAe,GAA0C,EAAE,EAC3DC,mBAAmB,GAAuBC,kBAAkB,EAAE,EACxD;IACN,MAAMC,SAAA,GAAYC,IAAI,CAACC,KAAK,CAACJ,mBAAmB,CAAC;IACjD,MAAMK,IAAK,GAAEC,iBAAiB,CAACV,eAAe,CAAC;IAC/C,MAAMW,IAAK,GAAEC,YAAY,CAACT,eAAe,CAAC;IAC1C,MAAMU,IAAK,GAAEC,YAAY,CAACZ,eAAA,CAA0B;IAEpD,MAAMa,SAAA,GAAYC,YAAY,CAACjB,UAAU,EAAEU,IAAI,EAAEI,IAAI,EAAEF,IAAI,CAAC;IAE5D,IAAIM,UAAW,GAAE,IAAI,CAACzB,QAAQ,CAAC0B,GAAG,CAACH,SAAS,CAAC;IACjD;IACI,MAAMI,cAAA,GAAiBF,UAAA,IAAclB,UAAW,KAAIqB,eAAgB,GAAEH,UAAU,CAACI,MAAM,CAACC,MAAA,GAAS,CAAC;IAElG,IAAIL,UAAU,EAAE;MACdA,UAAU,CAACI,MAAM,CAACvB,GAAG,CAACG,KAAK,CAAC;MAClC;MACM,IAAIgB,UAAU,CAACX,SAAU,GAAEA,SAAS,EAAE;QACpCW,UAAU,CAACX,SAAU,GAAEA,SAAS;MACxC;IACA,OAAW;MACLW,UAAA,GAAa;QACnB;QACQI,MAAM,EAAE,IAAIE,UAAU,CAACxB,UAAU,CAAC,CAACE,KAAK,CAAC;QACzCK,SAAS;QACTP,UAAU;QACVU,IAAI;QACJI,IAAI;QACJF;MACR,CAAO;MACD,IAAI,CAACnB,QAAQ,CAACgC,GAAG,CAACT,SAAS,EAAEE,UAAU,CAAC;IAC9C;;IAEA;IACI,MAAMQ,GAAI,GAAE,OAAOxB,KAAA,KAAU,QAAS,GAAEgB,UAAU,CAACI,MAAM,CAACC,MAAA,GAASH,cAAA,GAAiBlB,KAAK;IACzFyB,+BAA+B,CAAC3B,UAAU,EAAEU,IAAI,EAAEgB,GAAG,EAAEZ,IAAI,EAAEV,eAAe,EAAEY,SAAS,CAAC;EAC5F;;EAEA;AACA;AACA;EACSnB,KAAKA,CAAA,EAAS;IACvB;IACI,IAAI,IAAI,CAACJ,QAAQ,CAACmC,IAAA,KAAS,CAAC,EAAE;MAC5B;IACN;IAEI,IAAI,IAAI,CAACpC,OAAO,CAACqC,uBAAuB,EAAE;MAC9C;MACM,MAAMC,aAAA,GAAgBC,KAAK,CAACC,IAAI,CAAC,IAAI,CAACvC,QAAQ,CAAC,CAACwC,GAAG,CAAC,CAAC,GAAGf,UAAU,CAAC,KAAKA,UAAU,CAAC;MACnF,IAAI,CAAC1B,OAAO,CAACqC,uBAAuB,CAACC,aAAa,CAAC;IACzD;IAEI,IAAI,CAACrC,QAAQ,CAACyC,KAAK,EAAE;EACzB;;EAEA;AACA;AACA;EACSC,KAAKA,CAAA,EAAS;IACnBC,aAAa,CAAC,IAAI,CAACzC,SAAS,CAAC;IAC7B,IAAI,CAACE,KAAK,EAAE;EAChB;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}