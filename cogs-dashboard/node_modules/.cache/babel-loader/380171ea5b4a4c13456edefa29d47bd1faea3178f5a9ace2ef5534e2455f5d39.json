{"ast":null,"code":"import { createEnvelope, dsnFromString, forEachEnvelopeItem } from '@sentry/utils';\nimport { getEnvelopeEndpointWithUrlEncodedAuth } from '../api.js';\n\n/**\n * Gets an event from an envelope.\n *\n * This is only exported for use in the tests\n */\nfunction eventFromEnvelope(env, types) {\n  let event;\n  forEachEnvelopeItem(env, (item, type) => {\n    if (types.includes(type)) {\n      event = Array.isArray(item) ? item[1] : undefined;\n    }\n    // bail out if we found an event\n    return !!event;\n  });\n  return event;\n}\n\n/**\n * Creates a transport that overrides the release on all events.\n */\nfunction makeOverrideReleaseTransport(createTransport, release) {\n  return options => {\n    const transport = createTransport(options);\n    return {\n      ...transport,\n      send: async envelope => {\n        const event = eventFromEnvelope(envelope, ['event', 'transaction', 'profile', 'replay_event']);\n        if (event) {\n          event.release = release;\n        }\n        return transport.send(envelope);\n      }\n    };\n  };\n}\n\n/** Overrides the DSN in the envelope header  */\nfunction overrideDsn(envelope, dsn) {\n  return createEnvelope(dsn ? {\n    ...envelope[0],\n    dsn\n  } : envelope[0], envelope[1]);\n}\n\n/**\n * Creates a transport that can send events to different DSNs depending on the envelope contents.\n */\nfunction makeMultiplexedTransport(createTransport, matcher) {\n  return options => {\n    const fallbackTransport = createTransport(options);\n    const otherTransports = new Map();\n    function getTransport(dsn, release) {\n      // We create a transport for every unique dsn/release combination as there may be code from multiple releases in\n      // use at the same time\n      const key = release ? `${dsn}:${release}` : dsn;\n      let transport = otherTransports.get(key);\n      if (!transport) {\n        const validatedDsn = dsnFromString(dsn);\n        if (!validatedDsn) {\n          return undefined;\n        }\n        const url = getEnvelopeEndpointWithUrlEncodedAuth(validatedDsn, options.tunnel);\n        transport = release ? makeOverrideReleaseTransport(createTransport, release)({\n          ...options,\n          url\n        }) : createTransport({\n          ...options,\n          url\n        });\n        otherTransports.set(key, transport);\n      }\n      return [dsn, transport];\n    }\n    async function send(envelope) {\n      function getEvent(types) {\n        const eventTypes = types && types.length ? types : ['event'];\n        return eventFromEnvelope(envelope, eventTypes);\n      }\n      const transports = matcher({\n        envelope,\n        getEvent\n      }).map(result => {\n        if (typeof result === 'string') {\n          return getTransport(result, undefined);\n        } else {\n          return getTransport(result.dsn, result.release);\n        }\n      }).filter(t => !!t);\n\n      // If we have no transports to send to, use the fallback transport\n      if (transports.length === 0) {\n        // Don't override the DSN in the header for the fallback transport. '' is falsy\n        transports.push(['', fallbackTransport]);\n      }\n      const results = await Promise.all(transports.map(_ref => {\n        let [dsn, transport] = _ref;\n        return transport.send(overrideDsn(envelope, dsn));\n      }));\n      return results[0];\n    }\n    async function flush(timeout) {\n      const promises = [await fallbackTransport.flush(timeout)];\n      for (const [, transport] of otherTransports) {\n        promises.push(await transport.flush(timeout));\n      }\n      return promises.every(r => r);\n    }\n    return {\n      send,\n      flush\n    };\n  };\n}\nexport { eventFromEnvelope, makeMultiplexedTransport };","map":{"version":3,"names":["eventFromEnvelope","env","types","event","forEachEnvelopeItem","item","type","includes","Array","isArray","undefined","makeOverrideReleaseTransport","createTransport","release","options","transport","send","envelope","overrideDsn","dsn","createEnvelope","makeMultiplexedTransport","matcher","fallbackTransport","otherTransports","Map","getTransport","key","get","validatedDsn","dsnFromString","url","getEnvelopeEndpointWithUrlEncodedAuth","tunnel","set","getEvent","eventTypes","length","transports","map","result","filter","t","push","results","Promise","all","_ref","flush","timeout","promises","every","r"],"sources":["/Users/jeffreydebolt/Documents/fifo/cogs-dashboard/node_modules/@sentry/src/transports/multiplexed.ts"],"sourcesContent":["import type {\n  BaseTransportOptions,\n  Envelope,\n  EnvelopeItemType,\n  Event,\n  EventItem,\n  Transport,\n  TransportMakeRequestResponse,\n} from '@sentry/types';\nimport { createEnvelope, dsnFromString, forEachEnvelopeItem } from '@sentry/utils';\n\nimport { getEnvelopeEndpointWithUrlEncodedAuth } from '../api';\n\ninterface MatchParam {\n  /** The envelope to be sent */\n  envelope: Envelope;\n  /**\n   * A function that returns an event from the envelope if one exists. You can optionally pass an array of envelope item\n   * types to filter by - only envelopes matching the given types will be multiplexed.\n   * Allowed values are: 'event', 'transaction', 'profile', 'replay_event'\n   *\n   * @param types Defaults to ['event']\n   */\n  getEvent(types?: EnvelopeItemType[]): Event | undefined;\n}\n\ntype RouteTo = { dsn: string; release: string };\ntype Matcher = (param: MatchParam) => (string | RouteTo)[];\n\n/**\n * Gets an event from an envelope.\n *\n * This is only exported for use in the tests\n */\nexport function eventFromEnvelope(env: Envelope, types: EnvelopeItemType[]): Event | undefined {\n  let event: Event | undefined;\n\n  forEachEnvelopeItem(env, (item, type) => {\n    if (types.includes(type)) {\n      event = Array.isArray(item) ? (item as EventItem)[1] : undefined;\n    }\n    // bail out if we found an event\n    return !!event;\n  });\n\n  return event;\n}\n\n/**\n * Creates a transport that overrides the release on all events.\n */\nfunction makeOverrideReleaseTransport<TO extends BaseTransportOptions>(\n  createTransport: (options: TO) => Transport,\n  release: string,\n): (options: TO) => Transport {\n  return options => {\n    const transport = createTransport(options);\n\n    return {\n      ...transport,\n      send: async (envelope: Envelope): Promise<void | TransportMakeRequestResponse> => {\n        const event = eventFromEnvelope(envelope, ['event', 'transaction', 'profile', 'replay_event']);\n\n        if (event) {\n          event.release = release;\n        }\n        return transport.send(envelope);\n      },\n    };\n  };\n}\n\n/** Overrides the DSN in the envelope header  */\nfunction overrideDsn(envelope: Envelope, dsn: string): Envelope {\n  return createEnvelope(\n    dsn\n      ? {\n          ...envelope[0],\n          dsn,\n        }\n      : envelope[0],\n    envelope[1],\n  );\n}\n\n/**\n * Creates a transport that can send events to different DSNs depending on the envelope contents.\n */\nexport function makeMultiplexedTransport<TO extends BaseTransportOptions>(\n  createTransport: (options: TO) => Transport,\n  matcher: Matcher,\n): (options: TO) => Transport {\n  return options => {\n    const fallbackTransport = createTransport(options);\n    const otherTransports = new Map<string, Transport>();\n\n    function getTransport(dsn: string, release: string | undefined): [string, Transport] | undefined {\n      // We create a transport for every unique dsn/release combination as there may be code from multiple releases in\n      // use at the same time\n      const key = release ? `${dsn}:${release}` : dsn;\n\n      let transport = otherTransports.get(key);\n\n      if (!transport) {\n        const validatedDsn = dsnFromString(dsn);\n        if (!validatedDsn) {\n          return undefined;\n        }\n\n        const url = getEnvelopeEndpointWithUrlEncodedAuth(validatedDsn, options.tunnel);\n\n        transport = release\n          ? makeOverrideReleaseTransport(createTransport, release)({ ...options, url })\n          : createTransport({ ...options, url });\n\n        otherTransports.set(key, transport);\n      }\n\n      return [dsn, transport];\n    }\n\n    async function send(envelope: Envelope): Promise<void | TransportMakeRequestResponse> {\n      function getEvent(types?: EnvelopeItemType[]): Event | undefined {\n        const eventTypes: EnvelopeItemType[] = types && types.length ? types : ['event'];\n        return eventFromEnvelope(envelope, eventTypes);\n      }\n\n      const transports = matcher({ envelope, getEvent })\n        .map(result => {\n          if (typeof result === 'string') {\n            return getTransport(result, undefined);\n          } else {\n            return getTransport(result.dsn, result.release);\n          }\n        })\n        .filter((t): t is [string, Transport] => !!t);\n\n      // If we have no transports to send to, use the fallback transport\n      if (transports.length === 0) {\n        // Don't override the DSN in the header for the fallback transport. '' is falsy\n        transports.push(['', fallbackTransport]);\n      }\n\n      const results = await Promise.all(\n        transports.map(([dsn, transport]) => transport.send(overrideDsn(envelope, dsn))),\n      );\n\n      return results[0];\n    }\n\n    async function flush(timeout: number | undefined): Promise<boolean> {\n      const promises = [await fallbackTransport.flush(timeout)];\n      for (const [, transport] of otherTransports) {\n        promises.push(await transport.flush(timeout));\n      }\n\n      return promises.every(r => r);\n    }\n\n    return {\n      send,\n      flush,\n    };\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}