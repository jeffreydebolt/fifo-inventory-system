{"ast":null,"code":"import { timestampInSeconds } from '@sentry/utils';\nimport { DEFAULT_BROWSER_FLUSH_INTERVAL, SET_METRIC_TYPE } from './constants.js';\nimport { METRIC_MAP } from './instance.js';\nimport { updateMetricSummaryOnActiveSpan } from './metric-summary.js';\nimport { sanitizeMetricKey, sanitizeTags, sanitizeUnit, getBucketKey } from './utils.js';\n\n/**\n * A simple metrics aggregator that aggregates metrics in memory and flushes them periodically.\n * Default flush interval is 5 seconds.\n *\n * @experimental This API is experimental and might change in the future.\n */\nclass BrowserMetricsAggregator {\n  // TODO(@anonrig): Use FinalizationRegistry to have a proper way of flushing the buckets\n  // when the aggregator is garbage collected.\n  // Ref: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry\n\n  constructor(_client) {\n    this._client = _client;\n    this._buckets = new Map();\n    this._interval = setInterval(() => this.flush(), DEFAULT_BROWSER_FLUSH_INTERVAL);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  add(metricType, unsanitizedName, value) {\n    let unsanitizedUnit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'none';\n    let unsanitizedTags = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    let maybeFloatTimestamp = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : timestampInSeconds();\n    const timestamp = Math.floor(maybeFloatTimestamp);\n    const name = sanitizeMetricKey(unsanitizedName);\n    const tags = sanitizeTags(unsanitizedTags);\n    const unit = sanitizeUnit(unsanitizedUnit);\n    const bucketKey = getBucketKey(metricType, name, unit, tags);\n    let bucketItem = this._buckets.get(bucketKey);\n    // If this is a set metric, we need to calculate the delta from the previous weight.\n    const previousWeight = bucketItem && metricType === SET_METRIC_TYPE ? bucketItem.metric.weight : 0;\n    if (bucketItem) {\n      bucketItem.metric.add(value);\n      // TODO(abhi): Do we need this check?\n      if (bucketItem.timestamp < timestamp) {\n        bucketItem.timestamp = timestamp;\n      }\n    } else {\n      bucketItem = {\n        // @ts-expect-error we don't need to narrow down the type of value here, saves bundle size.\n        metric: new METRIC_MAP[metricType](value),\n        timestamp,\n        metricType,\n        name,\n        unit,\n        tags\n      };\n      this._buckets.set(bucketKey, bucketItem);\n    }\n\n    // If value is a string, it's a set metric so calculate the delta from the previous weight.\n    const val = typeof value === 'string' ? bucketItem.metric.weight - previousWeight : value;\n    updateMetricSummaryOnActiveSpan(metricType, name, val, unit, unsanitizedTags, bucketKey);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  flush() {\n    // short circuit if buckets are empty.\n    if (this._buckets.size === 0) {\n      return;\n    }\n    if (this._client.captureAggregateMetrics) {\n      // TODO(@anonrig): Use Object.values() when we support ES6+\n      const metricBuckets = Array.from(this._buckets).map(_ref => {\n        let [, bucketItem] = _ref;\n        return bucketItem;\n      });\n      this._client.captureAggregateMetrics(metricBuckets);\n    }\n    this._buckets.clear();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  close() {\n    clearInterval(this._interval);\n    this.flush();\n  }\n}\nexport { BrowserMetricsAggregator };","map":{"version":3,"names":["BrowserMetricsAggregator","constructor","_client","_buckets","Map","_interval","setInterval","flush","DEFAULT_BROWSER_FLUSH_INTERVAL","add","metricType","unsanitizedName","value","unsanitizedUnit","arguments","length","undefined","unsanitizedTags","maybeFloatTimestamp","timestampInSeconds","timestamp","Math","floor","name","sanitizeMetricKey","tags","sanitizeTags","unit","sanitizeUnit","bucketKey","getBucketKey","bucketItem","get","previousWeight","SET_METRIC_TYPE","metric","weight","METRIC_MAP","set","val","updateMetricSummaryOnActiveSpan","size","captureAggregateMetrics","metricBuckets","Array","from","map","_ref","clear","close","clearInterval"],"sources":["/Users/jeffreydebolt/Documents/fifo/cogs-dashboard/node_modules/@sentry/src/metrics/browser-aggregator.ts"],"sourcesContent":["import type { Client, ClientOptions, MeasurementUnit, MetricsAggregator, Primitive } from '@sentry/types';\nimport { timestampInSeconds } from '@sentry/utils';\nimport { DEFAULT_BROWSER_FLUSH_INTERVAL, SET_METRIC_TYPE } from './constants';\nimport { METRIC_MAP } from './instance';\nimport { updateMetricSummaryOnActiveSpan } from './metric-summary';\nimport type { MetricBucket, MetricType } from './types';\nimport { getBucketKey, sanitizeMetricKey, sanitizeTags, sanitizeUnit } from './utils';\n\n/**\n * A simple metrics aggregator that aggregates metrics in memory and flushes them periodically.\n * Default flush interval is 5 seconds.\n *\n * @experimental This API is experimental and might change in the future.\n */\nexport class BrowserMetricsAggregator implements MetricsAggregator {\n  // TODO(@anonrig): Use FinalizationRegistry to have a proper way of flushing the buckets\n  // when the aggregator is garbage collected.\n  // Ref: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry\n  private _buckets: MetricBucket;\n  private readonly _interval: ReturnType<typeof setInterval>;\n\n  public constructor(private readonly _client: Client<ClientOptions>) {\n    this._buckets = new Map();\n    this._interval = setInterval(() => this.flush(), DEFAULT_BROWSER_FLUSH_INTERVAL);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public add(\n    metricType: MetricType,\n    unsanitizedName: string,\n    value: number | string,\n    unsanitizedUnit: MeasurementUnit | undefined = 'none',\n    unsanitizedTags: Record<string, Primitive> | undefined = {},\n    maybeFloatTimestamp: number | undefined = timestampInSeconds(),\n  ): void {\n    const timestamp = Math.floor(maybeFloatTimestamp);\n    const name = sanitizeMetricKey(unsanitizedName);\n    const tags = sanitizeTags(unsanitizedTags);\n    const unit = sanitizeUnit(unsanitizedUnit as string);\n\n    const bucketKey = getBucketKey(metricType, name, unit, tags);\n\n    let bucketItem = this._buckets.get(bucketKey);\n    // If this is a set metric, we need to calculate the delta from the previous weight.\n    const previousWeight = bucketItem && metricType === SET_METRIC_TYPE ? bucketItem.metric.weight : 0;\n\n    if (bucketItem) {\n      bucketItem.metric.add(value);\n      // TODO(abhi): Do we need this check?\n      if (bucketItem.timestamp < timestamp) {\n        bucketItem.timestamp = timestamp;\n      }\n    } else {\n      bucketItem = {\n        // @ts-expect-error we don't need to narrow down the type of value here, saves bundle size.\n        metric: new METRIC_MAP[metricType](value),\n        timestamp,\n        metricType,\n        name,\n        unit,\n        tags,\n      };\n      this._buckets.set(bucketKey, bucketItem);\n    }\n\n    // If value is a string, it's a set metric so calculate the delta from the previous weight.\n    const val = typeof value === 'string' ? bucketItem.metric.weight - previousWeight : value;\n    updateMetricSummaryOnActiveSpan(metricType, name, val, unit, unsanitizedTags, bucketKey);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public flush(): void {\n    // short circuit if buckets are empty.\n    if (this._buckets.size === 0) {\n      return;\n    }\n\n    if (this._client.captureAggregateMetrics) {\n      // TODO(@anonrig): Use Object.values() when we support ES6+\n      const metricBuckets = Array.from(this._buckets).map(([, bucketItem]) => bucketItem);\n      this._client.captureAggregateMetrics(metricBuckets);\n    }\n\n    this._buckets.clear();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public close(): void {\n    clearInterval(this._interval);\n    this.flush();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}