{"ast":null,"code":"import { logger, uuid4, normalize, GLOBAL_OBJ } from '@sentry/utils';\nimport * as localForage from 'localforage';\nimport { DEBUG_BUILD } from './debug-build.js';\nconst WINDOW = GLOBAL_OBJ;\n\n/**\n * cache offline errors and send when connected\n * @deprecated The offline integration has been deprecated in favor of the offline transport wrapper.\n *\n * http://docs.sentry.io/platforms/javascript/configuration/transports/#offline-caching\n */\nclass Offline {\n  /**\n   * @inheritDoc\n   */\n  static __initStatic() {\n    this.id = 'Offline';\n  }\n\n  /**\n   * @inheritDoc\n   */\n\n  /**\n   * the current hub instance\n   */\n\n  /**\n   * maximum number of events to store while offline\n   */\n\n  /**\n   * event cache\n   */\n\n  /**\n   * @inheritDoc\n   */\n  constructor(options = {}) {\n    this.name = Offline.id;\n    this.maxStoredEvents = options.maxStoredEvents || 30; // set a reasonable default\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    this.offlineEventStore = localForage.createInstance({\n      name: 'sentry/offlineEventStore'\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  setupOnce(addGlobalEventProcessor, getCurrentHub) {\n    this.hub = getCurrentHub();\n    if ('addEventListener' in WINDOW) {\n      WINDOW.addEventListener('online', () => {\n        void this._sendEvents().catch(() => {\n          DEBUG_BUILD && logger.warn('could not send cached events');\n        });\n      });\n    }\n    const eventProcessor = event => {\n      // eslint-disable-next-line deprecation/deprecation\n      if (this.hub && this.hub.getIntegration(Offline)) {\n        // cache if we are positively offline\n        if ('navigator' in WINDOW && 'onLine' in WINDOW.navigator && !WINDOW.navigator.onLine) {\n          DEBUG_BUILD && logger.log('Event dropped due to being a offline - caching instead');\n          void this._cacheEvent(event).then(_event => this._enforceMaxEvents()).catch(_error => {\n            DEBUG_BUILD && logger.warn('could not cache event while offline');\n          });\n\n          // return null on success or failure, because being offline will still result in an error\n          return null;\n        }\n      }\n      return event;\n    };\n    eventProcessor.id = this.name;\n    addGlobalEventProcessor(eventProcessor);\n\n    // if online now, send any events stored in a previous offline session\n    if ('navigator' in WINDOW && 'onLine' in WINDOW.navigator && WINDOW.navigator.onLine) {\n      void this._sendEvents().catch(() => {\n        DEBUG_BUILD && logger.warn('could not send cached events');\n      });\n    }\n  }\n\n  /**\n   * cache an event to send later\n   * @param event an event\n   */\n  async _cacheEvent(event) {\n    return this.offlineEventStore.setItem(uuid4(), normalize(event));\n  }\n\n  /**\n   * purge excess events if necessary\n   */\n  async _enforceMaxEvents() {\n    const events = [];\n    return this.offlineEventStore.iterate((event, cacheKey, _index) => {\n      // aggregate events\n      events.push({\n        cacheKey,\n        event\n      });\n    }).then(() =>\n    // this promise resolves when the iteration is finished\n    this._purgeEvents(\n    // purge all events past maxStoredEvents in reverse chronological order\n    events.sort((a, b) => (b.event.timestamp || 0) - (a.event.timestamp || 0)).slice(this.maxStoredEvents < events.length ? this.maxStoredEvents : events.length).map(event => event.cacheKey))).catch(_error => {\n      DEBUG_BUILD && logger.warn('could not enforce max events');\n    });\n  }\n\n  /**\n   * purge event from cache\n   */\n  async _purgeEvent(cacheKey) {\n    return this.offlineEventStore.removeItem(cacheKey);\n  }\n\n  /**\n   * purge events from cache\n   */\n  async _purgeEvents(cacheKeys) {\n    // trail with .then to ensure the return type as void and not void|void[]\n    return Promise.all(cacheKeys.map(cacheKey => this._purgeEvent(cacheKey))).then();\n  }\n\n  /**\n   * send all events\n   */\n  async _sendEvents() {\n    return this.offlineEventStore.iterate((event, cacheKey, _index) => {\n      if (this.hub) {\n        this.hub.captureEvent(event);\n        void this._purgeEvent(cacheKey).catch(_error => {\n          DEBUG_BUILD && logger.warn('could not purge event from cache');\n        });\n      } else {\n        DEBUG_BUILD && logger.warn('no hub found - could not send cached event');\n      }\n    });\n  }\n}\nOffline.__initStatic();\nexport { Offline };","map":{"version":3,"names":["WINDOW","GLOBAL_OBJ","Offline","__initStatic","id","constructor","options","name","maxStoredEvents","offlineEventStore","localForage","createInstance","setupOnce","addGlobalEventProcessor","getCurrentHub","hub","addEventListener","_sendEvents","catch","DEBUG_BUILD","logger","warn","eventProcessor","event","getIntegration","navigator","onLine","log","_cacheEvent","then","_event","_enforceMaxEvents","_error","setItem","uuid4","normalize","events","iterate","cacheKey","_index","push","_purgeEvents","sort","a","b","timestamp","slice","length","map","_purgeEvent","removeItem","cacheKeys","Promise","all","captureEvent"],"sources":["/Users/jeffreydebolt/Documents/fifo/cogs-dashboard/node_modules/src/offline.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable deprecation/deprecation */\nimport type { Event, EventProcessor, Hub, Integration } from '@sentry/types';\nimport { GLOBAL_OBJ, logger, normalize, uuid4 } from '@sentry/utils';\nimport * as localForage from 'localforage';\n\nimport { DEBUG_BUILD } from './debug-build';\n\nconst WINDOW = GLOBAL_OBJ as typeof GLOBAL_OBJ & Window;\n\ntype LocalForage = {\n  setItem<T>(key: string, value: T, callback?: (err: any, value: T) => void): Promise<T>;\n  iterate<T, U>(\n    iteratee: (value: T, key: string, iterationNumber: number) => U,\n    callback?: (err: any, result: U) => void,\n  ): Promise<U>;\n  removeItem(key: string, callback?: (err: any) => void): Promise<void>;\n  length(): Promise<number>;\n};\n\nexport type Item = { key: string; value: Event };\n\n/**\n * cache offline errors and send when connected\n * @deprecated The offline integration has been deprecated in favor of the offline transport wrapper.\n *\n * http://docs.sentry.io/platforms/javascript/configuration/transports/#offline-caching\n */\nexport class Offline implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'Offline';\n\n  /**\n   * @inheritDoc\n   */\n  public readonly name: string;\n\n  /**\n   * the current hub instance\n   */\n  public hub?: Hub;\n\n  /**\n   * maximum number of events to store while offline\n   */\n  public maxStoredEvents: number;\n\n  /**\n   * event cache\n   */\n  public offlineEventStore: LocalForage;\n\n  /**\n   * @inheritDoc\n   */\n  public constructor(options: { maxStoredEvents?: number } = {}) {\n    this.name = Offline.id;\n\n    this.maxStoredEvents = options.maxStoredEvents || 30; // set a reasonable default\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    this.offlineEventStore = localForage.createInstance({\n      name: 'sentry/offlineEventStore',\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(addGlobalEventProcessor: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void {\n    this.hub = getCurrentHub();\n\n    if ('addEventListener' in WINDOW) {\n      WINDOW.addEventListener('online', () => {\n        void this._sendEvents().catch(() => {\n          DEBUG_BUILD && logger.warn('could not send cached events');\n        });\n      });\n    }\n\n    const eventProcessor: EventProcessor = event => {\n      // eslint-disable-next-line deprecation/deprecation\n      if (this.hub && this.hub.getIntegration(Offline)) {\n        // cache if we are positively offline\n        if ('navigator' in WINDOW && 'onLine' in WINDOW.navigator && !WINDOW.navigator.onLine) {\n          DEBUG_BUILD && logger.log('Event dropped due to being a offline - caching instead');\n\n          void this._cacheEvent(event)\n            .then((_event: Event): Promise<void> => this._enforceMaxEvents())\n            .catch((_error): void => {\n              DEBUG_BUILD && logger.warn('could not cache event while offline');\n            });\n\n          // return null on success or failure, because being offline will still result in an error\n          return null;\n        }\n      }\n\n      return event;\n    };\n\n    eventProcessor.id = this.name;\n    addGlobalEventProcessor(eventProcessor);\n\n    // if online now, send any events stored in a previous offline session\n    if ('navigator' in WINDOW && 'onLine' in WINDOW.navigator && WINDOW.navigator.onLine) {\n      void this._sendEvents().catch(() => {\n        DEBUG_BUILD && logger.warn('could not send cached events');\n      });\n    }\n  }\n\n  /**\n   * cache an event to send later\n   * @param event an event\n   */\n  private async _cacheEvent(event: Event): Promise<Event> {\n    return this.offlineEventStore.setItem<Event>(uuid4(), normalize(event));\n  }\n\n  /**\n   * purge excess events if necessary\n   */\n  private async _enforceMaxEvents(): Promise<void> {\n    const events: Array<{ event: Event; cacheKey: string }> = [];\n\n    return this.offlineEventStore\n      .iterate<Event, void>((event: Event, cacheKey: string, _index: number): void => {\n        // aggregate events\n        events.push({ cacheKey, event });\n      })\n      .then(\n        (): Promise<void> =>\n          // this promise resolves when the iteration is finished\n          this._purgeEvents(\n            // purge all events past maxStoredEvents in reverse chronological order\n            events\n              .sort((a, b) => (b.event.timestamp || 0) - (a.event.timestamp || 0))\n              .slice(this.maxStoredEvents < events.length ? this.maxStoredEvents : events.length)\n              .map(event => event.cacheKey),\n          ),\n      )\n      .catch((_error): void => {\n        DEBUG_BUILD && logger.warn('could not enforce max events');\n      });\n  }\n\n  /**\n   * purge event from cache\n   */\n  private async _purgeEvent(cacheKey: string): Promise<void> {\n    return this.offlineEventStore.removeItem(cacheKey);\n  }\n\n  /**\n   * purge events from cache\n   */\n  private async _purgeEvents(cacheKeys: string[]): Promise<void> {\n    // trail with .then to ensure the return type as void and not void|void[]\n    return Promise.all(cacheKeys.map(cacheKey => this._purgeEvent(cacheKey))).then();\n  }\n\n  /**\n   * send all events\n   */\n  private async _sendEvents(): Promise<void> {\n    return this.offlineEventStore.iterate<Event, void>((event: Event, cacheKey: string, _index: number): void => {\n      if (this.hub) {\n        this.hub.captureEvent(event);\n\n        void this._purgeEvent(cacheKey).catch((_error): void => {\n          DEBUG_BUILD && logger.warn('could not purge event from cache');\n        });\n      } else {\n        DEBUG_BUILD && logger.warn('no hub found - could not send cached event');\n      }\n    });\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}