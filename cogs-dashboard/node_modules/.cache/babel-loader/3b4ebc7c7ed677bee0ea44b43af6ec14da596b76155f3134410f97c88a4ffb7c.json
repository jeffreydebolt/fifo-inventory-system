{"ast":null,"code":"import { spanToJSON, hasTracingEnabled, setHttpStatus, getCurrentScope, getIsolationScope, startInactiveSpan, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, getClient, spanToTraceHeader, getDynamicSamplingContextFromSpan, getDynamicSamplingContextFromClient } from '@sentry/core';\nimport { addFetchInstrumentationHandler, parseUrl, addXhrInstrumentationHandler, SENTRY_XHR_DATA_KEY, generateSentryTraceHeader, dynamicSamplingContextToSentryBaggageHeader, BAGGAGE_HEADER_NAME, browserPerformanceTimeOrigin, stringMatchesSomePattern } from '@sentry/utils';\nimport { instrumentFetchRequest } from '../common/fetch.js';\nimport { addPerformanceInstrumentationHandler } from './instrument.js';\nimport { WINDOW } from './types.js';\n\n/* eslint-disable max-lines */\n\nconst DEFAULT_TRACE_PROPAGATION_TARGETS = ['localhost', /^\\/(?!\\/)/];\n\n/** Options for Request Instrumentation */\n\nconst defaultRequestInstrumentationOptions = {\n  traceFetch: true,\n  traceXHR: true,\n  enableHTTPTimings: true,\n  // TODO (v8): Remove this property\n  tracingOrigins: DEFAULT_TRACE_PROPAGATION_TARGETS,\n  tracePropagationTargets: DEFAULT_TRACE_PROPAGATION_TARGETS\n};\n\n/** Registers span creators for xhr and fetch requests  */\nfunction instrumentOutgoingRequests(_options) {\n  const {\n    traceFetch,\n    traceXHR,\n    // eslint-disable-next-line deprecation/deprecation\n    tracePropagationTargets,\n    // eslint-disable-next-line deprecation/deprecation\n    tracingOrigins,\n    shouldCreateSpanForRequest,\n    enableHTTPTimings\n  } = {\n    traceFetch: defaultRequestInstrumentationOptions.traceFetch,\n    traceXHR: defaultRequestInstrumentationOptions.traceXHR,\n    ..._options\n  };\n  const shouldCreateSpan = typeof shouldCreateSpanForRequest === 'function' ? shouldCreateSpanForRequest : _ => true;\n\n  // TODO(v8) Remove tracingOrigins here\n  // The only reason we're passing it in here is because this instrumentOutgoingRequests function is publicly exported\n  // and we don't want to break the API. We can remove it in v8.\n  const shouldAttachHeadersWithTargets = url => shouldAttachHeaders(url, tracePropagationTargets || tracingOrigins);\n  const spans = {};\n  if (traceFetch) {\n    addFetchInstrumentationHandler(handlerData => {\n      const createdSpan = instrumentFetchRequest(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);\n      // We cannot use `window.location` in the generic fetch instrumentation,\n      // but we need it for reliable `server.address` attribute.\n      // so we extend this in here\n      if (createdSpan) {\n        const fullUrl = getFullURL(handlerData.fetchData.url);\n        const host = fullUrl ? parseUrl(fullUrl).host : undefined;\n        createdSpan.setAttributes({\n          'http.url': fullUrl,\n          'server.address': host\n        });\n      }\n      if (enableHTTPTimings && createdSpan) {\n        addHTTPTimings(createdSpan);\n      }\n    });\n  }\n  if (traceXHR) {\n    addXhrInstrumentationHandler(handlerData => {\n      const createdSpan = xhrCallback(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);\n      if (enableHTTPTimings && createdSpan) {\n        addHTTPTimings(createdSpan);\n      }\n    });\n  }\n}\nfunction isPerformanceResourceTiming(entry) {\n  return entry.entryType === 'resource' && 'initiatorType' in entry && typeof entry.nextHopProtocol === 'string' && (entry.initiatorType === 'fetch' || entry.initiatorType === 'xmlhttprequest');\n}\n\n/**\n * Creates a temporary observer to listen to the next fetch/xhr resourcing timings,\n * so that when timings hit their per-browser limit they don't need to be removed.\n *\n * @param span A span that has yet to be finished, must contain `url` on data.\n */\nfunction addHTTPTimings(span) {\n  const {\n    url\n  } = spanToJSON(span).data || {};\n  if (!url || typeof url !== 'string') {\n    return;\n  }\n  const cleanup = addPerformanceInstrumentationHandler('resource', _ref => {\n    let {\n      entries\n    } = _ref;\n    entries.forEach(entry => {\n      if (isPerformanceResourceTiming(entry) && entry.name.endsWith(url)) {\n        const spanData = resourceTimingEntryToSpanData(entry);\n        spanData.forEach(data => span.setAttribute(...data));\n        // In the next tick, clean this handler up\n        // We have to wait here because otherwise this cleans itself up before it is fully done\n        setTimeout(cleanup);\n      }\n    });\n  });\n}\n\n/**\n * Converts ALPN protocol ids to name and version.\n *\n * (https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)\n * @param nextHopProtocol PerformanceResourceTiming.nextHopProtocol\n */\nfunction extractNetworkProtocol(nextHopProtocol) {\n  let name = 'unknown';\n  let version = 'unknown';\n  let _name = '';\n  for (const char of nextHopProtocol) {\n    // http/1.1 etc.\n    if (char === '/') {\n      [name, version] = nextHopProtocol.split('/');\n      break;\n    }\n    // h2, h3 etc.\n    if (!isNaN(Number(char))) {\n      name = _name === 'h' ? 'http' : _name;\n      version = nextHopProtocol.split(_name)[1];\n      break;\n    }\n    _name += char;\n  }\n  if (_name === nextHopProtocol) {\n    // webrtc, ftp, etc.\n    name = _name;\n  }\n  return {\n    name,\n    version\n  };\n}\nfunction getAbsoluteTime() {\n  let time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  return ((browserPerformanceTimeOrigin || performance.timeOrigin) + time) / 1000;\n}\nfunction resourceTimingEntryToSpanData(resourceTiming) {\n  const {\n    name,\n    version\n  } = extractNetworkProtocol(resourceTiming.nextHopProtocol);\n  const timingSpanData = [];\n  timingSpanData.push(['network.protocol.version', version], ['network.protocol.name', name]);\n  if (!browserPerformanceTimeOrigin) {\n    return timingSpanData;\n  }\n  return [...timingSpanData, ['http.request.redirect_start', getAbsoluteTime(resourceTiming.redirectStart)], ['http.request.fetch_start', getAbsoluteTime(resourceTiming.fetchStart)], ['http.request.domain_lookup_start', getAbsoluteTime(resourceTiming.domainLookupStart)], ['http.request.domain_lookup_end', getAbsoluteTime(resourceTiming.domainLookupEnd)], ['http.request.connect_start', getAbsoluteTime(resourceTiming.connectStart)], ['http.request.secure_connection_start', getAbsoluteTime(resourceTiming.secureConnectionStart)], ['http.request.connection_end', getAbsoluteTime(resourceTiming.connectEnd)], ['http.request.request_start', getAbsoluteTime(resourceTiming.requestStart)], ['http.request.response_start', getAbsoluteTime(resourceTiming.responseStart)], ['http.request.response_end', getAbsoluteTime(resourceTiming.responseEnd)]];\n}\n\n/**\n * A function that determines whether to attach tracing headers to a request.\n * This was extracted from `instrumentOutgoingRequests` to make it easier to test shouldAttachHeaders.\n * We only export this fuction for testing purposes.\n */\nfunction shouldAttachHeaders(url, tracePropagationTargets) {\n  return stringMatchesSomePattern(url, tracePropagationTargets || DEFAULT_TRACE_PROPAGATION_TARGETS);\n}\n\n/**\n * Create and track xhr request spans\n *\n * @returns Span if a span was created, otherwise void.\n */\n// eslint-disable-next-line complexity\nfunction xhrCallback(handlerData, shouldCreateSpan, shouldAttachHeaders, spans) {\n  const xhr = handlerData.xhr;\n  const sentryXhrData = xhr && xhr[SENTRY_XHR_DATA_KEY];\n  if (!hasTracingEnabled() || !xhr || xhr.__sentry_own_request__ || !sentryXhrData) {\n    return undefined;\n  }\n  const shouldCreateSpanResult = shouldCreateSpan(sentryXhrData.url);\n\n  // check first if the request has finished and is tracked by an existing span which should now end\n  if (handlerData.endTimestamp && shouldCreateSpanResult) {\n    const spanId = xhr.__sentry_xhr_span_id__;\n    if (!spanId) return;\n    const span = spans[spanId];\n    if (span && sentryXhrData.status_code !== undefined) {\n      setHttpStatus(span, sentryXhrData.status_code);\n      span.end();\n\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete spans[spanId];\n    }\n    return undefined;\n  }\n  const scope = getCurrentScope();\n  const isolationScope = getIsolationScope();\n  const fullUrl = getFullURL(sentryXhrData.url);\n  const host = fullUrl ? parseUrl(fullUrl).host : undefined;\n  const span = shouldCreateSpanResult ? startInactiveSpan({\n    name: `${sentryXhrData.method} ${sentryXhrData.url}`,\n    onlyIfParent: true,\n    attributes: {\n      type: 'xhr',\n      'http.method': sentryXhrData.method,\n      'http.url': fullUrl,\n      url: sentryXhrData.url,\n      'server.address': host,\n      [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.browser'\n    },\n    op: 'http.client'\n  }) : undefined;\n  if (span) {\n    xhr.__sentry_xhr_span_id__ = span.spanContext().spanId;\n    spans[xhr.__sentry_xhr_span_id__] = span;\n  }\n  const client = getClient();\n  if (xhr.setRequestHeader && shouldAttachHeaders(sentryXhrData.url) && client) {\n    const {\n      traceId,\n      spanId,\n      sampled,\n      dsc\n    } = {\n      ...isolationScope.getPropagationContext(),\n      ...scope.getPropagationContext()\n    };\n    const sentryTraceHeader = span ? spanToTraceHeader(span) : generateSentryTraceHeader(traceId, spanId, sampled);\n    const sentryBaggageHeader = dynamicSamplingContextToSentryBaggageHeader(dsc || (span ? getDynamicSamplingContextFromSpan(span) : getDynamicSamplingContextFromClient(traceId, client, scope)));\n    setHeaderOnXhr(xhr, sentryTraceHeader, sentryBaggageHeader);\n  }\n  return span;\n}\nfunction setHeaderOnXhr(xhr, sentryTraceHeader, sentryBaggageHeader) {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    xhr.setRequestHeader('sentry-trace', sentryTraceHeader);\n    if (sentryBaggageHeader) {\n      // From MDN: \"If this method is called several times with the same header, the values are merged into one single request header.\"\n      // We can therefore simply set a baggage header without checking what was there before\n      // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      xhr.setRequestHeader(BAGGAGE_HEADER_NAME, sentryBaggageHeader);\n    }\n  } catch (_) {\n    // Error: InvalidStateError: Failed to execute 'setRequestHeader' on 'XMLHttpRequest': The object's state must be OPENED.\n  }\n}\nfunction getFullURL(url) {\n  try {\n    // By adding a base URL to new URL(), this will also work for relative urls\n    // If `url` is a full URL, the base URL is ignored anyhow\n    const parsed = new URL(url, WINDOW.location.origin);\n    return parsed.href;\n  } catch (e) {\n    return undefined;\n  }\n}\nexport { DEFAULT_TRACE_PROPAGATION_TARGETS, defaultRequestInstrumentationOptions, extractNetworkProtocol, instrumentOutgoingRequests, shouldAttachHeaders, xhrCallback };","map":{"version":3,"names":["DEFAULT_TRACE_PROPAGATION_TARGETS","defaultRequestInstrumentationOptions","traceFetch","traceXHR","enableHTTPTimings","tracingOrigins","tracePropagationTargets","instrumentOutgoingRequests","_options","shouldCreateSpanForRequest","shouldCreateSpan","_","shouldAttachHeadersWithTargets","url","shouldAttachHeaders","spans","addFetchInstrumentationHandler","handlerData","createdSpan","instrumentFetchRequest","fullUrl","getFullURL","fetchData","host","parseUrl","undefined","setAttributes","addHTTPTimings","addXhrInstrumentationHandler","xhrCallback","isPerformanceResourceTiming","entry","entryType","nextHopProtocol","initiatorType","span","spanToJSON","data","cleanup","addPerformanceInstrumentationHandler","_ref","entries","forEach","name","endsWith","spanData","resourceTimingEntryToSpanData","setAttribute","setTimeout","extractNetworkProtocol","version","_name","char","split","isNaN","Number","getAbsoluteTime","time","arguments","length","browserPerformanceTimeOrigin","performance","timeOrigin","resourceTiming","timingSpanData","push","redirectStart","fetchStart","domainLookupStart","domainLookupEnd","connectStart","secureConnectionStart","connectEnd","requestStart","responseStart","responseEnd","stringMatchesSomePattern","xhr","sentryXhrData","SENTRY_XHR_DATA_KEY","hasTracingEnabled","__sentry_own_request__","shouldCreateSpanResult","endTimestamp","spanId","__sentry_xhr_span_id__","status_code","setHttpStatus","end","scope","getCurrentScope","isolationScope","getIsolationScope","startInactiveSpan","method","onlyIfParent","attributes","type","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","op","spanContext","client","getClient","setRequestHeader","traceId","sampled","dsc","getPropagationContext","sentryTraceHeader","spanToTraceHeader","generateSentryTraceHeader","sentryBaggageHeader","dynamicSamplingContextToSentryBaggageHeader","getDynamicSamplingContextFromSpan","getDynamicSamplingContextFromClient","setHeaderOnXhr","BAGGAGE_HEADER_NAME","parsed","URL","WINDOW","location","origin","href","e"],"sources":["/Users/jeffreydebolt/Documents/fifo/cogs-dashboard/node_modules/@sentry-internal/src/browser/request.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport {\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  getClient,\n  getCurrentScope,\n  getDynamicSamplingContextFromClient,\n  getDynamicSamplingContextFromSpan,\n  getIsolationScope,\n  hasTracingEnabled,\n  setHttpStatus,\n  spanToJSON,\n  spanToTraceHeader,\n  startInactiveSpan,\n} from '@sentry/core';\nimport type { HandlerDataXhr, SentryWrappedXMLHttpRequest, Span } from '@sentry/types';\nimport {\n  BAGGAGE_HEADER_NAME,\n  SENTRY_XHR_DATA_KEY,\n  addFetchInstrumentationHandler,\n  addXhrInstrumentationHandler,\n  browserPerformanceTimeOrigin,\n  dynamicSamplingContextToSentryBaggageHeader,\n  generateSentryTraceHeader,\n  parseUrl,\n  stringMatchesSomePattern,\n} from '@sentry/utils';\n\nimport { instrumentFetchRequest } from '../common/fetch';\nimport { addPerformanceInstrumentationHandler } from './instrument';\nimport { WINDOW } from './types';\n\nexport const DEFAULT_TRACE_PROPAGATION_TARGETS = ['localhost', /^\\/(?!\\/)/];\n\n/** Options for Request Instrumentation */\nexport interface RequestInstrumentationOptions {\n  /**\n   * @deprecated Will be removed in v8.\n   * Use `shouldCreateSpanForRequest` to control span creation and `tracePropagationTargets` to control\n   * trace header attachment.\n   */\n  tracingOrigins: Array<string | RegExp>;\n\n  /**\n   * List of strings and/or regexes used to determine which outgoing requests will have `sentry-trace` and `baggage`\n   * headers attached.\n   *\n   * @deprecated Use the top-level `tracePropagationTargets` option in `Sentry.init` instead.\n   * This option will be removed in v8.\n   *\n   * Default: ['localhost', /^\\//] @see {DEFAULT_TRACE_PROPAGATION_TARGETS}\n   */\n  tracePropagationTargets: Array<string | RegExp>;\n\n  /**\n   * Flag to disable patching all together for fetch requests.\n   *\n   * Default: true\n   */\n  traceFetch: boolean;\n\n  /**\n   * Flag to disable patching all together for xhr requests.\n   *\n   * Default: true\n   */\n  traceXHR: boolean;\n\n  /**\n   * If true, Sentry will capture http timings and add them to the corresponding http spans.\n   *\n   * Default: true\n   */\n  enableHTTPTimings: boolean;\n\n  /**\n   * This function will be called before creating a span for a request with the given url.\n   * Return false if you don't want a span for the given url.\n   *\n   * Default: (url: string) => true\n   */\n  shouldCreateSpanForRequest?(this: void, url: string): boolean;\n}\n\nexport const defaultRequestInstrumentationOptions: RequestInstrumentationOptions = {\n  traceFetch: true,\n  traceXHR: true,\n  enableHTTPTimings: true,\n  // TODO (v8): Remove this property\n  tracingOrigins: DEFAULT_TRACE_PROPAGATION_TARGETS,\n  tracePropagationTargets: DEFAULT_TRACE_PROPAGATION_TARGETS,\n};\n\n/** Registers span creators for xhr and fetch requests  */\nexport function instrumentOutgoingRequests(_options?: Partial<RequestInstrumentationOptions>): void {\n  const {\n    traceFetch,\n    traceXHR,\n    // eslint-disable-next-line deprecation/deprecation\n    tracePropagationTargets,\n    // eslint-disable-next-line deprecation/deprecation\n    tracingOrigins,\n    shouldCreateSpanForRequest,\n    enableHTTPTimings,\n  } = {\n    traceFetch: defaultRequestInstrumentationOptions.traceFetch,\n    traceXHR: defaultRequestInstrumentationOptions.traceXHR,\n    ..._options,\n  };\n\n  const shouldCreateSpan =\n    typeof shouldCreateSpanForRequest === 'function' ? shouldCreateSpanForRequest : (_: string) => true;\n\n  // TODO(v8) Remove tracingOrigins here\n  // The only reason we're passing it in here is because this instrumentOutgoingRequests function is publicly exported\n  // and we don't want to break the API. We can remove it in v8.\n  const shouldAttachHeadersWithTargets = (url: string): boolean =>\n    shouldAttachHeaders(url, tracePropagationTargets || tracingOrigins);\n\n  const spans: Record<string, Span> = {};\n\n  if (traceFetch) {\n    addFetchInstrumentationHandler(handlerData => {\n      const createdSpan = instrumentFetchRequest(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);\n      // We cannot use `window.location` in the generic fetch instrumentation,\n      // but we need it for reliable `server.address` attribute.\n      // so we extend this in here\n      if (createdSpan) {\n        const fullUrl = getFullURL(handlerData.fetchData.url);\n        const host = fullUrl ? parseUrl(fullUrl).host : undefined;\n        createdSpan.setAttributes({\n          'http.url': fullUrl,\n          'server.address': host,\n        });\n      }\n\n      if (enableHTTPTimings && createdSpan) {\n        addHTTPTimings(createdSpan);\n      }\n    });\n  }\n\n  if (traceXHR) {\n    addXhrInstrumentationHandler(handlerData => {\n      const createdSpan = xhrCallback(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);\n      if (enableHTTPTimings && createdSpan) {\n        addHTTPTimings(createdSpan);\n      }\n    });\n  }\n}\n\nfunction isPerformanceResourceTiming(entry: PerformanceEntry): entry is PerformanceResourceTiming {\n  return (\n    entry.entryType === 'resource' &&\n    'initiatorType' in entry &&\n    typeof (entry as PerformanceResourceTiming).nextHopProtocol === 'string' &&\n    (entry.initiatorType === 'fetch' || entry.initiatorType === 'xmlhttprequest')\n  );\n}\n\n/**\n * Creates a temporary observer to listen to the next fetch/xhr resourcing timings,\n * so that when timings hit their per-browser limit they don't need to be removed.\n *\n * @param span A span that has yet to be finished, must contain `url` on data.\n */\nfunction addHTTPTimings(span: Span): void {\n  const { url } = spanToJSON(span).data || {};\n\n  if (!url || typeof url !== 'string') {\n    return;\n  }\n\n  const cleanup = addPerformanceInstrumentationHandler('resource', ({ entries }) => {\n    entries.forEach(entry => {\n      if (isPerformanceResourceTiming(entry) && entry.name.endsWith(url)) {\n        const spanData = resourceTimingEntryToSpanData(entry);\n        spanData.forEach(data => span.setAttribute(...data));\n        // In the next tick, clean this handler up\n        // We have to wait here because otherwise this cleans itself up before it is fully done\n        setTimeout(cleanup);\n      }\n    });\n  });\n}\n\n/**\n * Converts ALPN protocol ids to name and version.\n *\n * (https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)\n * @param nextHopProtocol PerformanceResourceTiming.nextHopProtocol\n */\nexport function extractNetworkProtocol(nextHopProtocol: string): { name: string; version: string } {\n  let name = 'unknown';\n  let version = 'unknown';\n  let _name = '';\n  for (const char of nextHopProtocol) {\n    // http/1.1 etc.\n    if (char === '/') {\n      [name, version] = nextHopProtocol.split('/');\n      break;\n    }\n    // h2, h3 etc.\n    if (!isNaN(Number(char))) {\n      name = _name === 'h' ? 'http' : _name;\n      version = nextHopProtocol.split(_name)[1];\n      break;\n    }\n    _name += char;\n  }\n  if (_name === nextHopProtocol) {\n    // webrtc, ftp, etc.\n    name = _name;\n  }\n  return { name, version };\n}\n\nfunction getAbsoluteTime(time: number = 0): number {\n  return ((browserPerformanceTimeOrigin || performance.timeOrigin) + time) / 1000;\n}\n\nfunction resourceTimingEntryToSpanData(resourceTiming: PerformanceResourceTiming): [string, string | number][] {\n  const { name, version } = extractNetworkProtocol(resourceTiming.nextHopProtocol);\n\n  const timingSpanData: [string, string | number][] = [];\n\n  timingSpanData.push(['network.protocol.version', version], ['network.protocol.name', name]);\n\n  if (!browserPerformanceTimeOrigin) {\n    return timingSpanData;\n  }\n  return [\n    ...timingSpanData,\n    ['http.request.redirect_start', getAbsoluteTime(resourceTiming.redirectStart)],\n    ['http.request.fetch_start', getAbsoluteTime(resourceTiming.fetchStart)],\n    ['http.request.domain_lookup_start', getAbsoluteTime(resourceTiming.domainLookupStart)],\n    ['http.request.domain_lookup_end', getAbsoluteTime(resourceTiming.domainLookupEnd)],\n    ['http.request.connect_start', getAbsoluteTime(resourceTiming.connectStart)],\n    ['http.request.secure_connection_start', getAbsoluteTime(resourceTiming.secureConnectionStart)],\n    ['http.request.connection_end', getAbsoluteTime(resourceTiming.connectEnd)],\n    ['http.request.request_start', getAbsoluteTime(resourceTiming.requestStart)],\n    ['http.request.response_start', getAbsoluteTime(resourceTiming.responseStart)],\n    ['http.request.response_end', getAbsoluteTime(resourceTiming.responseEnd)],\n  ];\n}\n\n/**\n * A function that determines whether to attach tracing headers to a request.\n * This was extracted from `instrumentOutgoingRequests` to make it easier to test shouldAttachHeaders.\n * We only export this fuction for testing purposes.\n */\nexport function shouldAttachHeaders(url: string, tracePropagationTargets: (string | RegExp)[] | undefined): boolean {\n  return stringMatchesSomePattern(url, tracePropagationTargets || DEFAULT_TRACE_PROPAGATION_TARGETS);\n}\n\n/**\n * Create and track xhr request spans\n *\n * @returns Span if a span was created, otherwise void.\n */\n// eslint-disable-next-line complexity\nexport function xhrCallback(\n  handlerData: HandlerDataXhr,\n  shouldCreateSpan: (url: string) => boolean,\n  shouldAttachHeaders: (url: string) => boolean,\n  spans: Record<string, Span>,\n): Span | undefined {\n  const xhr = handlerData.xhr;\n  const sentryXhrData = xhr && xhr[SENTRY_XHR_DATA_KEY];\n\n  if (!hasTracingEnabled() || !xhr || xhr.__sentry_own_request__ || !sentryXhrData) {\n    return undefined;\n  }\n\n  const shouldCreateSpanResult = shouldCreateSpan(sentryXhrData.url);\n\n  // check first if the request has finished and is tracked by an existing span which should now end\n  if (handlerData.endTimestamp && shouldCreateSpanResult) {\n    const spanId = xhr.__sentry_xhr_span_id__;\n    if (!spanId) return;\n\n    const span = spans[spanId];\n    if (span && sentryXhrData.status_code !== undefined) {\n      setHttpStatus(span, sentryXhrData.status_code);\n      span.end();\n\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete spans[spanId];\n    }\n    return undefined;\n  }\n\n  const scope = getCurrentScope();\n  const isolationScope = getIsolationScope();\n\n  const fullUrl = getFullURL(sentryXhrData.url);\n  const host = fullUrl ? parseUrl(fullUrl).host : undefined;\n\n  const span = shouldCreateSpanResult\n    ? startInactiveSpan({\n        name: `${sentryXhrData.method} ${sentryXhrData.url}`,\n        onlyIfParent: true,\n        attributes: {\n          type: 'xhr',\n          'http.method': sentryXhrData.method,\n          'http.url': fullUrl,\n          url: sentryXhrData.url,\n          'server.address': host,\n          [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.browser',\n        },\n        op: 'http.client',\n      })\n    : undefined;\n\n  if (span) {\n    xhr.__sentry_xhr_span_id__ = span.spanContext().spanId;\n    spans[xhr.__sentry_xhr_span_id__] = span;\n  }\n\n  const client = getClient();\n\n  if (xhr.setRequestHeader && shouldAttachHeaders(sentryXhrData.url) && client) {\n    const { traceId, spanId, sampled, dsc } = {\n      ...isolationScope.getPropagationContext(),\n      ...scope.getPropagationContext(),\n    };\n\n    const sentryTraceHeader = span ? spanToTraceHeader(span) : generateSentryTraceHeader(traceId, spanId, sampled);\n\n    const sentryBaggageHeader = dynamicSamplingContextToSentryBaggageHeader(\n      dsc ||\n        (span ? getDynamicSamplingContextFromSpan(span) : getDynamicSamplingContextFromClient(traceId, client, scope)),\n    );\n\n    setHeaderOnXhr(xhr, sentryTraceHeader, sentryBaggageHeader);\n  }\n\n  return span;\n}\n\nfunction setHeaderOnXhr(\n  xhr: SentryWrappedXMLHttpRequest,\n  sentryTraceHeader: string,\n  sentryBaggageHeader: string | undefined,\n): void {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    xhr.setRequestHeader!('sentry-trace', sentryTraceHeader);\n    if (sentryBaggageHeader) {\n      // From MDN: \"If this method is called several times with the same header, the values are merged into one single request header.\"\n      // We can therefore simply set a baggage header without checking what was there before\n      // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      xhr.setRequestHeader!(BAGGAGE_HEADER_NAME, sentryBaggageHeader);\n    }\n  } catch (_) {\n    // Error: InvalidStateError: Failed to execute 'setRequestHeader' on 'XMLHttpRequest': The object's state must be OPENED.\n  }\n}\n\nfunction getFullURL(url: string): string | undefined {\n  try {\n    // By adding a base URL to new URL(), this will also work for relative urls\n    // If `url` is a full URL, the base URL is ignored anyhow\n    const parsed = new URL(url, WINDOW.location.origin);\n    return parsed.href;\n  } catch {\n    return undefined;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}